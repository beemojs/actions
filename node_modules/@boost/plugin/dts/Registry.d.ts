import { Blueprint, Contract, ModuleName, Predicates } from '@boost/common';
import { Debugger } from '@boost/debug';
import { Event } from '@boost/event';
import { Pluggable, RegisterOptions, Registration, RegistryOptions, Setting, Source, SourceWithOptions } from './types';
export declare class Registry<Plugin extends Pluggable, Tool = unknown> extends Contract<RegistryOptions<Plugin>> {
    readonly debug: Debugger;
    /**
     * Called after a plugin is registered.
     * @category Events
     */
    readonly onAfterRegister: Event<[Plugin], string>;
    /**
     * Called after a plugin is unregistered.
     * @category Events
     */
    readonly onAfterUnregister: Event<[Plugin], string>;
    /**
     * Called before a plugin is registered and the `startup` life-cycle.
     * @category Events
     */
    readonly onBeforeRegister: Event<[Plugin], string>;
    /**
     * Called before a plugin is unregistered and the `shutdown` life-cycle.
     * @category Events
     */
    readonly onBeforeUnregister: Event<[Plugin], string>;
    /**
     * Called after a plugin is loaded but before it's registered.
     * @category Events
     */
    readonly onLoad: Event<[string, object], string>;
    readonly pluralName: string;
    readonly projectName: string;
    readonly singularName: string;
    private loader;
    private plugins;
    constructor(projectName: string, typeName: string, options: RegistryOptions<Plugin>);
    blueprint(predicates: Predicates): Blueprint<RegistryOptions<Plugin>>;
    /**
     * Format a name into a fully qualified and compatible Node/npm module name,
     * with the tool and type names being used as scopes and prefixes.
     */
    formatModuleName(name: string, scoped?: boolean): ModuleName;
    /**
     * Return a single registered plugin by module name. If the plugin cannot be found,
     * an error will be thrown.
     */
    get<T extends Plugin = Plugin>(name: ModuleName): T;
    /**
     * Return all registered plugins.
     */
    getAll(): Plugin[];
    /**
     * Return multiple registered plugins by module name.
     */
    getMany(names: ModuleName[]): Plugin[];
    /**
     * Load and register a single plugin by name, or with an explicit instance.
     */
    load(source: Plugin | Source, params?: object, options?: RegisterOptions<Tool>): Promise<Plugin>;
    /**
     * Load and register multiple plugins based on a list of settings.
     */
    loadMany(settings: (Plugin | Source | SourceWithOptions)[] | Setting, options?: RegisterOptions<Tool>): Promise<Plugin[]>;
    /**
     * Return true if a plugin has been registered.
     */
    isRegistered(name: ModuleName): boolean;
    /**
     * Register a plugin and trigger startup with the provided tool.
     */
    register(name: ModuleName, plugin: Plugin, tool?: Tool | undefined, options?: RegisterOptions<Tool>): Promise<Plugin>;
    /**
     * Unregister a plugin by name and trigger shutdown process.
     */
    unregister(name: ModuleName, tool?: Tool): Promise<Plugin>;
    /**
     * Verify a passed name matches one of many possible module name variants for this plugin.
     */
    protected isMatchingName(container: Registration<Plugin>, name: string): boolean;
    /**
     * Trigger shutdown events for the registry and plugin.
     */
    protected triggerShutdown(plugin: Plugin, tool?: Tool): Promise<void>;
    /**
     * Trigger startup events for the registry and plugin.
     */
    protected triggerStartup(plugin: Plugin, tool?: Tool): Promise<void>;
}
//# sourceMappingURL=Registry.d.ts.map