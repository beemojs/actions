'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var kebabCase = require('lodash/kebabCase');

var upperFirst = require('lodash/upperFirst');

var pluralize = require('pluralize');

var common = require('@boost/common');

var debug = require('@boost/debug');

var event = require('@boost/event');

var internal = require('@boost/internal');

var constants = require('./constants.js');

var debug$1 = require('./debug.js');

var Loader = require('./Loader.js');

var PluginError = require('./PluginError.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var kebabCase__default = /*#__PURE__*/_interopDefault(kebabCase);

var upperFirst__default = /*#__PURE__*/_interopDefault(upperFirst);

var pluralize__default = /*#__PURE__*/_interopDefault(pluralize);

class Registry extends common.Contract {
  /**
   * Called after a plugin is registered.
   * @category Events
   */

  /**
   * Called after a plugin is unregistered.
   * @category Events
   */

  /**
   * Called before a plugin is registered and the `startup` life-cycle.
   * @category Events
   */

  /**
   * Called before a plugin is unregistered and the `shutdown` life-cycle.
   * @category Events
   */

  /**
   * Called after a plugin is loaded but before it's registered.
   * @category Events
   */
  constructor(projectName, typeName, options) {
    super(options);
    this.debug = void 0;
    this.onAfterRegister = new event.Event('after-register');
    this.onAfterUnregister = new event.Event('after-unregister');
    this.onBeforeRegister = new event.Event('before-register');
    this.onBeforeUnregister = new event.Event('before-unregister');
    this.onLoad = new event.Event('load');
    this.pluralName = void 0;
    this.projectName = void 0;
    this.singularName = void 0;
    this.loader = void 0;
    this.plugins = [];
    this.projectName = kebabCase__default['default'](projectName);
    this.singularName = kebabCase__default['default'](typeName);
    this.pluralName = pluralize__default['default'](this.singularName);
    this.debug = debug.createDebugger([this.singularName, 'registry']);
    this.loader = new Loader.Loader(this);
    this.debug('Creating new plugin type: %s', internal.color.symbol(this.singularName));
    debug$1.debug('New plugin type created: %s', this.singularName);
  }

  blueprint(predicates) {
    const func = predicates.func;
    return {
      afterShutdown: func(),
      afterStartup: func(),
      beforeShutdown: func(),
      beforeStartup: func(),
      resolver: func(require.resolve).notNullable(),
      validate: func().notNullable().required()
    };
  }
  /**
   * Format a name into a fully qualified and compatible Node/npm module name,
   * with the tool and type names being used as scopes and prefixes.
   */


  formatModuleName(name, scoped = false) {
    if (scoped) {
      return `@${this.projectName}/${this.singularName}-${name.toLocaleLowerCase()}`;
    }

    return `${this.projectName}-${this.singularName}-${name.toLocaleLowerCase()}`;
  }
  /**
   * Return a single registered plugin by module name. If the plugin cannot be found,
   * an error will be thrown.
   */


  get(name) {
    const container = this.plugins.find(c => this.isMatchingName(c, name));

    if (container) {
      return container.plugin;
    }

    throw new PluginError.PluginError('PLUGIN_REQUIRED', [this.singularName, name]);
  }
  /**
   * Return all registered plugins.
   */


  getAll() {
    return this.plugins.map(container => container.plugin);
  }
  /**
   * Return multiple registered plugins by module name.
   */


  getMany(names) {
    return names.map(name => this.get(name));
  }
  /**
   * Load and register a single plugin by name, or with an explicit instance.
   */


  async load(source, params = {}, options = {}) {
    let plugin; // Plugin instance

    if (common.isObject(source)) {
      plugin = source;

      if (plugin.priority) {
        // eslint-disable-next-line no-param-reassign
        options.priority = plugin.priority;
      } // Options object

    } else if (typeof source === 'string') {
      plugin = await this.loader.load(source, params);
      this.onLoad.emit([source, params]); // Unknown setting
    } else {
      throw new PluginError.PluginError('SETTING_UNKNOWN', [source]);
    }

    if (!plugin.name) {
      throw new PluginError.PluginError('PLUGIN_REQUIRED_NAME');
    }

    return this.register(plugin.name, plugin, options.tool, options);
  }
  /**
   * Load and register multiple plugins based on a list of settings.
   */


  async loadMany(settings, options = {}) {
    const loaded = [];
    const toLoad = [];

    if (Array.isArray(settings)) {
      settings.forEach(setting => {
        if (typeof setting === 'string') {
          toLoad.push([setting, {}]);
        } else if (Array.isArray(setting)) {
          toLoad.push(setting);
        } else {
          loaded.push(this.load(setting, {}, options));
        }
      });
    } else if (common.isObject(settings)) {
      toLoad.push(...Object.entries(settings));
    }

    return Promise.all([...loaded, ...toLoad.filter(([, params]) => params !== false && params !== undefined).map(([name, params]) => this.load(name, common.isObject(params) ? params : {}, options))]);
  }
  /**
   * Return true if a plugin has been registered.
   */


  isRegistered(name) {
    try {
      this.get(name);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Register a plugin and trigger startup with the provided tool.
   */


  async register(name, plugin, tool = undefined, options = {}) {
    const priority = options.priority;

    if (!name.match(common.MODULE_NAME_PATTERN)) {
      throw new PluginError.PluginError('MODULE_NAME_INVALID', [this.pluralName]);
    }

    if (!common.isObject(plugin)) {
      throw new PluginError.PluginError('REGISTER_REQUIRED', [upperFirst__default['default'](this.pluralName), typeof plugin]);
    }

    this.debug('Validating plugin %s', internal.color.moduleName(name));
    await this.options.validate(plugin);
    this.debug('Registering plugin %s and triggering startup', internal.color.moduleName(name));
    this.onBeforeRegister.emit([plugin]);
    await this.triggerStartup(plugin, tool);
    this.plugins.push({
      name,
      plugin,
      priority: priority !== null && priority !== void 0 ? priority : constants.DEFAULT_PRIORITY
    });
    this.plugins.sort((a, b) => a.priority - b.priority);
    this.onAfterRegister.emit([plugin]);
    debug$1.debug('Plugin "%s" registered', plugin.name || name);
    return plugin;
  }
  /**
   * Unregister a plugin by name and trigger shutdown process.
   */


  async unregister(name, tool) {
    const plugin = this.get(name);
    this.onBeforeUnregister.emit([plugin]);
    this.debug('Unregistering plugin %s and triggering shutdown', internal.color.moduleName(name));
    await this.triggerShutdown(plugin, tool);
    this.plugins = this.plugins.filter(container => !this.isMatchingName(container, name));
    this.onAfterUnregister.emit([plugin]);
    debug$1.debug('Plugin "%s" unregistered', plugin.name || name);
    return plugin;
  }
  /**
   * Verify a passed name matches one of many possible module name variants for this plugin.
   */


  isMatchingName(container, name) {
    if (container.name === name) {
      return true;
    }

    const internalModule = this.formatModuleName(name, true);
    const publicModule = this.formatModuleName(name);
    return container.name === internalModule || container.name === publicModule;
  }
  /**
   * Trigger shutdown events for the registry and plugin.
   */


  async triggerShutdown(plugin, tool) {
    const _this$options = this.options,
          afterShutdown = _this$options.afterShutdown,
          beforeShutdown = _this$options.beforeShutdown;

    if (beforeShutdown) {
      await beforeShutdown(plugin);
    }

    if (typeof plugin.shutdown === 'function') {
      await plugin.shutdown(tool);
    }

    if (afterShutdown) {
      await afterShutdown(plugin);
    }
  }
  /**
   * Trigger startup events for the registry and plugin.
   */


  async triggerStartup(plugin, tool) {
    const _this$options2 = this.options,
          afterStartup = _this$options2.afterStartup,
          beforeStartup = _this$options2.beforeStartup;

    if (beforeStartup) {
      await beforeStartup(plugin);
    }

    if (typeof plugin.startup === 'function') {
      await plugin.startup(tool);
    }

    if (afterStartup) {
      await afterStartup(plugin);
    }
  }

}

exports.Registry = Registry;
//# sourceMappingURL=Registry.js.map
