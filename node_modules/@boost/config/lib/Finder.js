'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var common = require('@boost/common');

var debug = require('@boost/debug');

var internal = require('@boost/internal');

var ConfigError = require('./ConfigError.js');

var constants = require('./constants.js');

class Finder extends common.Contract {
  constructor(options, cache) {
    super(options);
    this.debug = void 0;
    this.cache = void 0;
    this.cache = cache;
    this.debug = debug.createDebugger([this.constructor.name.toLowerCase(), this.options.name]);
  }
  /**
   * Traverse upwards from the branch directory, until the root directory is found,
   * or we reach to top of the file system. While traversing, find all files.
   */


  async loadFromBranchToRoot(dir) {
    const filesToLoad = [];
    const branch = common.Path.resolve(dir);
    let currentDir = branch.isDirectory() ? branch : branch.parent();
    this.debug('Loading files from branch %s to root', internal.color.filePath(branch.path()));

    while (!this.isFileSystemRoot(currentDir)) {
      // eslint-disable-next-line no-await-in-loop
      const files = await this.findFilesInDir(currentDir);

      if (files.length > 0) {
        filesToLoad.unshift(...files);
      }

      if (this.isRootDir(currentDir)) {
        break;
      } else {
        currentDir = currentDir.parent();
      }
    }

    return this.resolveFiles(branch, filesToLoad);
  }
  /**
   * Load files from the root, determined by a relative `.config` folder
   * and `package.json` file.
   */


  async loadFromRoot(dir = process.cwd()) {
    this.debug('Loading files from possible root %s', internal.color.filePath(String(dir)));
    const root = this.getRootDir(dir);
    const files = await this.findFilesInDir(root);
    return this.resolveFiles(root, files);
  }
  /**
   * Return the root directory path or throw an error.
   */


  getRootDir(dir) {
    const root = common.Path.resolve(dir);

    if (!this.isRootDir(root)) {
      throw new ConfigError.ConfigError('ROOT_INVALID', [constants.CONFIG_FOLDER]);
    }

    return root;
  }
  /**
   * Return true if the path represents the root of the file system.
   */


  isFileSystemRoot(path) {
    return /^(\/|[A-Z]:(?:\\|\/))$/u.test(path.path());
  }
  /**
   * Detect the root directory, config directory, and `package.json`
   * path from the provided directory path, and return true if valid.
   */


  isRootDir(dir, abort = false) {
    var _this$cache$rootDir;

    if (dir.path() === ((_this$cache$rootDir = this.cache.rootDir) === null || _this$cache$rootDir === void 0 ? void 0 : _this$cache$rootDir.path())) {
      return true;
    }

    if (!dir.isDirectory() || abort) {
      return false;
    }

    const configDir = dir.append(constants.CONFIG_FOLDER);
    const isValid = configDir.exists() && configDir.isDirectory();

    if (!isValid) {
      return false;
    }

    this.cache.configDir = configDir;
    this.cache.rootDir = dir;
    const pkgPath = dir.append(constants.PACKAGE_FILE);

    if (!pkgPath.exists()) {
      throw new ConfigError.ConfigError('ROOT_NO_PACKAGE', [constants.CONFIG_FOLDER]);
    }

    this.cache.pkgPath = pkgPath;
    this.debug('Project root found at %s', internal.color.filePath(dir.path()));
    return true;
  }

}

exports.Finder = Finder;
//# sourceMappingURL=Finder.js.map
