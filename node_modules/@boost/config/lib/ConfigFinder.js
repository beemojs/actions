'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var minimatch = require('minimatch');

var common = require('@boost/common');

var internal = require('@boost/internal');

var ConfigError = require('./ConfigError.js');

var constants = require('./constants.js');

var Finder = require('./Finder.js');

var createFileName = require('./helpers/createFileName.js');

var getEnv = require('./helpers/getEnv.js');

var cjs = require('./loaders/cjs.js');

var js = require('./loaders/js.js');

var json = require('./loaders/json.js');

var mjs = require('./loaders/mjs.js');

var ts = require('./loaders/ts.js');

var yaml = require('./loaders/yaml.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var minimatch__default = /*#__PURE__*/_interopDefault(minimatch);
/* eslint-disable no-param-reassign, no-await-in-loop */


class ConfigFinder extends Finder.Finder {
  blueprint(predicates) {
    const array = predicates.array,
          bool = predicates.bool,
          func = predicates.func,
          shape = predicates.shape,
          string = predicates.string;
    return {
      extendsSetting: string(),
      extensions: array(string(), constants.DEFAULT_EXTS),
      includeEnv: bool(true),
      loaders: shape({
        cjs: func(cjs.loadCjs).notNullable(),
        js: func(js.loadJs).notNullable(),
        json: func(json.loadJson).notNullable(),
        json5: func(json.loadJson).notNullable(),
        mjs: func(mjs.loadMjs).notNullable(),
        ts: func(ts.loadTs).notNullable(),
        yaml: func(yaml.loadYaml).notNullable(),
        yml: func(yaml.loadYaml).notNullable()
      }).exact(),
      name: string().required().camelCase(),
      overridesSetting: string(),
      resolver: func(require.resolve).notNullable()
    };
  }
  /**
   * Determine a files package scope by finding the first parent `package.json`
   * when traversing up directories. We will leverage the cache as much as
   * possible for performance.
   *
   * @see https://nodejs.org/api/esm.html#esm_package_scope_and_file_extensions
   */


  async determinePackageScope(dir) {
    let currentDir = dir.isDirectory() ? dir : dir.parent();
    this.debug('Determining package scope for %s', internal.color.filePath(dir.path()));

    while (!this.isFileSystemRoot(currentDir)) {
      const pkgPath = currentDir.append(constants.PACKAGE_FILE);
      const cache = this.cache.getFileCache(pkgPath);

      if (cache) {
        if (cache.exists) {
          this.debug('Scope found at %s', internal.color.filePath(pkgPath.path()));
          return cache.content;
        } // Fall-through

      } else if (pkgPath.exists()) {
        this.debug('Scope found at %s', internal.color.filePath(pkgPath.path()));
        return this.cache.cacheFileContents(pkgPath, () => json.loadJson(pkgPath));
      } else {
        this.cache.markMissingFile(pkgPath);
      }

      currentDir = currentDir.parent();
    }

    throw new ConfigError.ConfigError('PACKAGE_UNKNOWN_SCOPE');
  }
  /**
   * Find all configuration and environment specific files in a directory
   * by looping through all the defined extension options.
   * Will only search until the first file is found, and will not return multiple extensions.
   */


  async findFilesInDir(dir) {
    const isRoot = this.isRootDir(dir);
    const baseDir = isRoot ? dir.append(constants.CONFIG_FOLDER) : dir;
    return this.cache.cacheFilesInDir(baseDir, async () => {
      const paths = [];

      for (const ext of this.options.extensions) {
        const files = [baseDir.append(this.getFileName(ext, !isRoot, false))];

        if (this.options.includeEnv) {
          files.push(baseDir.append(this.getFileName(ext, !isRoot, true)));
        }

        await Promise.all(files.map(configPath => {
          if (configPath.exists()) {
            paths.push(configPath);
          }

          return configPath;
        })); // Once we find any file, we abort looking for others

        if (paths.length > 0) {
          break;
        }
      }

      this.debug.invariant(paths.length > 0, `Finding config files in ${internal.color.filePath(baseDir.path())}`, paths.map(path => path.name()).join(', '), 'No files'); // Make sure env takes higher precedence

      paths.sort((a, b) => a.path().length - b.path().length);
      return paths;
    });
  }
  /**
   * Create and return a config file name, with optional branch and environment variants.
   */


  getFileName(ext, isBranch, isEnv) {
    const name = this.options.name;
    return createFileName.createFileName(name, ext, {
      envSuffix: isEnv ? getEnv.getEnv(name) : '',
      leadingDot: isBranch
    });
  }
  /**
   * Load file and package contents from a list of file paths.
   * Extract and apply extended and override configs based on the base path.
   */


  async resolveFiles(basePath, foundFiles) {
    this.debug('Resolving %d config files', foundFiles.length);
    const configs = await Promise.all(foundFiles.map(filePath => this.loadConfig(filePath))); // Overrides take the highest precedence and must appear after everything,
    // including branch level configs. However, they must extract first so that
    // extends functionality can be inherited (below).

    if (this.options.overridesSetting) {
      const overriddenConfigs = await this.extractOverriddenConfigs(basePath, configs);
      this.debug('Overriding %d configs', overriddenConfigs.length);

      if (overriddenConfigs.length > 0) {
        configs.push(...overriddenConfigs);
      }
    } // Configs that have been extended from root configs must
    // appear before everything else, in the order they were defined


    if (this.options.extendsSetting) {
      const extendedConfigs = await this.extractExtendedConfigs(configs);
      this.debug('Extending %d configs', extendedConfigs.length);

      if (extendedConfigs.length > 0) {
        configs.unshift(...extendedConfigs);
      }
    }

    return configs;
  }
  /**
   * Extract a list of config files to extend, in order, from the list of previously loaded
   * config files, which is typically from the root. The list to extract can be located within
   * a property that matches the `extendsSetting` option.
   */


  async extractExtendedConfigs(configs) {
    const _this$options = this.options,
          name = _this$options.name,
          extendsSetting = _this$options.extendsSetting,
          resolver = _this$options.resolver;
    const extendsPaths = [];
    this.debug('Extracting configs to extend from');
    configs.forEach(({
      config,
      path,
      source
    }) => {
      const key = extendsSetting;
      const extendsFrom = config[key];

      if (source === 'root' || source === 'overridden') {
        delete config[key];
      } else if (extendsFrom) {
        throw new ConfigError.ConfigError('EXTENDS_ONLY_ROOT', [key]);
      } else {
        return;
      }

      common.toArray(extendsFrom).forEach(extendsPath => {
        // Node module
        if (common.isModuleName(extendsPath)) {
          const modulePath = new common.Path(extendsPath, createFileName.createFileName(name, 'js', {
            envSuffix: 'preset'
          }));
          this.debug('Extending config from node module: %s', internal.color.moduleName(modulePath.path()));
          extendsPaths.push(new common.Path(resolver(modulePath.path()))); // File path
        } else if (common.isFilePath(extendsPath)) {
          let filePath = new common.Path(extendsPath); // Relative to the config file its defined in

          if (!filePath.isAbsolute()) {
            filePath = path.parent().append(extendsPath);
          }

          this.debug('Extending config from file path: %s', internal.color.filePath(filePath.path()));
          extendsPaths.push(filePath); // Unknown
        } else {
          throw new ConfigError.ConfigError('EXTENDS_UNKNOWN_PATH', [extendsPath]);
        }
      });
    });
    return Promise.all(extendsPaths.map(path => this.loadConfig(path, 'extended')));
  }
  /**
   * Extract all root config overrides that match the current path used to load with.
   * Overrides are located within a property that matches the `overridesSetting` option.
   */


  extractOverriddenConfigs(basePath, configs) {
    const overridesSetting = this.options.overridesSetting;
    const overriddenConfigs = [];
    this.debug('Extracting configs to override with (matching against %s)', internal.color.filePath(basePath.path()));
    configs.forEach(({
      config,
      path,
      source
    }) => {
      const key = overridesSetting;
      const overrides = config[key];

      if (source === 'root') {
        delete config[key];
      } else if (overrides) {
        throw new ConfigError.ConfigError('ROOT_ONLY_OVERRIDES', [key]);
      } else {
        return;
      }

      common.toArray(overrides).forEach(({
        exclude,
        include,
        settings
      }) => {
        const options = {
          dot: true,
          matchBase: true
        };
        const excludePatterns = common.toArray(exclude);
        const excluded = excludePatterns.some(pattern => minimatch__default['default'](basePath.path(), pattern, options));
        const includePatterns = common.toArray(include);
        const included = includePatterns.some(pattern => minimatch__default['default'](basePath.path(), pattern, options));
        const passes = included && !excluded;
        this.debug.invariant(passes, `Matching with includes "${includePatterns}" and excludes "${excludePatterns}"`, 'Matched', // eslint-disable-next-line no-nested-ternary
        excluded ? 'Excluded' : included ? 'Not matched' : 'Not included');

        if (passes) {
          overriddenConfigs.push({
            config: settings,
            path,
            source: 'overridden'
          });
        }
      });
    });
    return overriddenConfigs;
  }
  /**
   * Load config contents from the provided file path using one of the defined loaders.
   */


  async loadConfig(path, source) {
    const pkg = await this.determinePackageScope(path);
    const config = await this.cache.cacheFileContents(path, async () => {
      const loaders = this.options.loaders;
      const ext = path.ext(true);
      this.debug('Loading config %s with type %s', internal.color.filePath(path.path()), internal.color.symbol(ext));

      switch (ext) {
        case 'cjs':
          return loaders.cjs(path, pkg);

        case 'js':
          return loaders.js(path, pkg);

        case 'json':
        case 'json5':
          return loaders.json(path, pkg);

        case 'mjs':
          // Not easily testable yet
          // istanbul ignore next
          return loaders.mjs(path, pkg);

        case 'ts':
        case 'tsx':
          return loaders.ts(path, pkg);

        case 'yaml':
        case 'yml':
          return loaders.yaml(path, pkg);

        default:
          throw new ConfigError.ConfigError('LOADER_UNSUPPORTED', [ext]);
      }
    });
    return {
      config,
      path,
      source: source !== null && source !== void 0 ? source : path.path().includes(constants.CONFIG_FOLDER) ? 'root' : 'branch'
    };
  }

}

exports.ConfigFinder = ConfigFinder;
//# sourceMappingURL=ConfigFinder.js.map
