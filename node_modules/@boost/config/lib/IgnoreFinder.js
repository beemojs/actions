'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var fs = require('fs');

var internal = require('@boost/internal');

var Finder = require('./Finder.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var fs__default = /*#__PURE__*/_interopDefault(fs);

class IgnoreFinder extends Finder.Finder {
  blueprint(predicates) {
    const string = predicates.string;
    return {
      name: string().required().camelCase()
    };
  }
  /**
   * Find a single ignore file in the provided directory.
   */


  async findFilesInDir(dir) {
    const files = [];
    const path = dir.append(this.getFileName());

    if (path.exists()) {
      files.push(path);
    }

    this.debug.invariant(files.length > 0, `Finding ignore files in ${internal.color.filePath(dir.path())}`, files.map(file => file.name()).join(', '), 'No files');
    return Promise.resolve(files);
  }
  /**
   * Return an ignore specific file.
   */


  getFileName() {
    return `.${this.options.name.toLowerCase()}ignore`;
  }
  /**
   * Load and parse a list of found files into a list of ignore patterns.
   */


  async resolveFiles(basePath, foundFiles) {
    this.debug('Resolving %d ignore files', foundFiles.length);
    return Promise.all(foundFiles.map(async filePath => {
      const contents = await this.cache.cacheFileContents(filePath, () => fs__default['default'].promises.readFile(filePath.path(), 'utf8'));
      const ignore = contents.split('\n').map(line => line.trim()).filter(line => line !== '' && !line.startsWith('#'));
      return {
        ignore,
        path: filePath,
        source: this.isRootDir(filePath.parent(), true) ? 'root' : 'branch'
      };
    }));
  }

}

exports.IgnoreFinder = IgnoreFinder;
//# sourceMappingURL=IgnoreFinder.js.map
