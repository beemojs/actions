// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: legacy, Format: lib
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var fs = require('fs');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var fs__default = /*#__PURE__*/_interopDefault(fs);
/* eslint-disable @typescript-eslint/consistent-type-assertions */

/**
 * Formats the shape of an imported module to align with the
 * ES module specification.
 *
 * For ES or ES-like modules, returns the shape as-is.
 *
 * For CommonJS modules, returns an object with the following:
 * - `module.exports` under the `default` property.
 * - `exports.<name>` under properties of the same name,
 *   and also under a `default` object.
 */


function interopModule(result) {
  if (typeof result !== 'object' || result === null) {
    return {
      default: result
    };
  } // Already a module, so return early


  if ('__esModule' in result || 'default' in result) {
    return result;
  }

  return _objectSpread(_objectSpread({}, result), {}, {
    default: result
  });
}
/* eslint-disable no-magic-numbers */


const COMPILER_OPTIONS = {
  allowJs: true,
  allowSyntheticDefaultImports: true,
  esModuleInterop: true,
  noEmit: true
};

function isTypeScript(path) {
  return path.endsWith('.ts') || path.endsWith('.tsx');
}

function getTargetFromNodeVersion(ts) {
  const version = Number.parseFloat(process.version.slice(1));

  if (version >= 16) {
    return ts.ScriptTarget.ES2020;
  }

  if (version >= 15) {
    return ts.ScriptTarget.ES2019;
  }

  if (version >= 14) {
    return ts.ScriptTarget.ES2018;
  }

  if (version >= 13) {
    return ts.ScriptTarget.ES2017;
  }

  if (version >= 12) {
    return ts.ScriptTarget.ES2016;
  }

  return ts.ScriptTarget.ES5;
}
/* eslint-disable no-underscore-dangle, node/no-deprecated-api */


let tsInstance = null;

function loadTypeScript() {
  if (!tsInstance) {
    try {
      tsInstance = require('typescript');
    } catch {// Ignore and check at runtime
    }
  }

  return tsInstance;
}

const transformCache = new Map();

function transform(contents, filePath) {
  const ts = loadTypeScript();

  if (!ts) {
    throw new Error(`\`typescript\` package required for transforming file "${filePath}".`);
  }

  return ts.transpileModule(contents, {
    compilerOptions: _objectSpread(_objectSpread({}, COMPILER_OPTIONS), {}, {
      module: ts.ModuleKind.CommonJS,
      resolveJsonModule: true,
      target: getTargetFromNodeVersion(ts)
    }),
    fileName: filePath
  }).outputText;
}

function transformHandler(mod, filePath) {
  let code = transformCache.get(filePath);

  if (!code) {
    code = transform(fs__default['default'].readFileSync(filePath, 'utf8'), filePath);
    transformCache.set(filePath, code);
  }

  mod._compile(code, filePath);
}
/**
 * Register `.ts` and `.tsx` file extensions into Node.js's resolution algorithm.
 */


function registerExtensions() {
  require.extensions['.ts'] = transformHandler;
  require.extensions['.tsx'] = transformHandler;
}
/**
 * Unregister `.ts` and `.tsx` file extensions.
 */


function unregisterExtensions() {
  delete require.extensions['.ts'];
  delete require.extensions['.tsx'];
}
/**
 * Like `requireModule` but for loading TypeScript files ending in `ts` or `tsx`.
 * When imported, will transform the file using the `typescript` package,
 * evaluate the code in the current module context, and apply the same process
 * to all child imports.
 *
 * ```ts
 * import { requireTSModule } from '@boost/module';
 *
 * const result = requireTSModule('../../some/module.ts');
 * ```
 *
 * > This helper rarely needs to be used directly as `requireModule` will
 * > call it under the hood based on the file extension.
 */


function requireTSModule(path, requirer = require) {
  const filePath = String(path);

  if (!isTypeScript(filePath)) {
    throw new Error(`Unable to import non-TypeScript file "${filePath}", use \`requireModule\` instead.`);
  }

  registerExtensions();
  const result = interopModule(requirer(filePath));
  unregisterExtensions();
  return result;
}
/**
 * Works in a similar fashion to the native NodeJS `require()`, but can also
 * import custom file types like TypeScript, and also returns a module shape
 * that aligns with the ESM loader specification.
 *
 * When loading custom file types, the extension in the file path is optional,
 * as NodeJS will iterate through each extension until a file is found.
 *
 * ```ts
 * import { requireModule } from '@boost/module';
 *
 * const result = requireModule('../../some/module');
 * ```
 *
 * Caveats and differences:
 *
 * - CommonJS files that utilize `module.exports` (default export) will have this
 *   value returned under a `default` property, instead of being returned directly.
 * - CommonJS files that utilize multiple `exports.<name>` (named exports) will
 *   have these values returned as properties on the result object, and will also
 *   be found on the `default` property.
 * - "ES module like" files will be returned as-is. These are files that are built
 *   with Babel or TypeScript and export an `__esModule` internal property.
 *
 * These changes align with `import()` and the ES module system. We made this
 * decision for consistency and reliability.
 */


function requireModule(path, requirer = require) {
  const filePath = String(path);

  if (filePath.endsWith('.mjs')) {
    throw new Error(`Unable to require non-CommonJS file "${filePath}", use ESM imports instead.`);
  }

  if (isTypeScript(filePath)) {
    return requireTSModule(filePath, requirer);
  }

  return interopModule(requirer(filePath));
}

exports.interopModule = interopModule;
exports.registerExtensions = registerExtensions;
exports.requireModule = requireModule;
exports.requireTSModule = requireTSModule;
exports.unregisterExtensions = unregisterExtensions;
//# sourceMappingURL=index.js.map
