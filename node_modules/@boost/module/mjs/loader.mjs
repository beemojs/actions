function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: legacy, Format: mjs
import fs from 'fs';
/* eslint-disable no-magic-numbers */

const COMPILER_OPTIONS = {
  allowJs: true,
  allowSyntheticDefaultImports: true,
  esModuleInterop: true,
  noEmit: true
};

function isTypeScript(path) {
  return path.endsWith('.ts') || path.endsWith('.tsx');
}

function getModuleFromNodeVersion(ts) {
  const version = Number.parseFloat(process.version.slice(1));

  if (version >= 15) {
    return ts.ModuleKind.ES2020;
  }

  if (version >= 12) {
    return ts.ModuleKind.ES2015;
  }

  return ts.ModuleKind.CommonJS;
}

function getTargetFromNodeVersion(ts) {
  const version = Number.parseFloat(process.version.slice(1));

  if (version >= 16) {
    return ts.ScriptTarget.ES2020;
  }

  if (version >= 15) {
    return ts.ScriptTarget.ES2019;
  }

  if (version >= 14) {
    return ts.ScriptTarget.ES2018;
  }

  if (version >= 13) {
    return ts.ScriptTarget.ES2017;
  }

  if (version >= 12) {
    return ts.ScriptTarget.ES2016;
  }

  return ts.ScriptTarget.ES5;
} // https://nodejs.org/api/esm.html#esm_loaders


const FILE_WITH_EXT_PATTERN = /\.[a-z]+$/;

async function loadTypeScript() {
  try {
    return (await import('typescript')).default;
  } catch {
    return null;
  }
}

const resolve$1 = async (specifier, context, defaultResolve) => {
  if (isTypeScript(specifier)) {
    return {
      url: new URL(specifier, context.parentURL).href
    };
  } // Relative import doesn't have an extension, so attempt to find a TS file


  if (specifier.startsWith('.') && !FILE_WITH_EXT_PATTERN.test(specifier)) {
    for (const ext of ['.ts', '.tsx']) {
      const url = new URL(specifier + ext, context.parentURL); // @ts-expect-error Node not typed for URLs

      if (fs.existsSync(url)) {
        return {
          url: url.href
        };
      }
    }
  }

  return defaultResolve(specifier, context);
};

const getFormat$1 = async (url, context, defaultGetFormat) => {
  if (isTypeScript(url)) {
    return {
      format: 'module'
    };
  }

  return defaultGetFormat(url, context);
};

const transformSource$1 = async (source, context, defaultTransformSource) => {
  const url = context.url;

  if (isTypeScript(url)) {
    const ts = await loadTypeScript();

    if (!ts) {
      throw new Error(`\`typescript\` package required for transforming file "${url}".`);
    }

    return {
      source: ts.transpileModule(String(source), {
        compilerOptions: _objectSpread(_objectSpread({}, COMPILER_OPTIONS), {}, {
          module: getModuleFromNodeVersion(ts),
          resolveJsonModule: false,
          target: getTargetFromNodeVersion(ts)
        }),
        fileName: url
      }).outputText
    };
  }

  return defaultTransformSource(source, context);
};

var typescript = /*#__PURE__*/Object.freeze({
  __proto__: null,
  resolve: resolve$1,
  getFormat: getFormat$1,
  transformSource: transformSource$1
}); // Once we have multiple loaders, we can iterate through them as a whole.

const resolve = typescript.resolve,
      getFormat = typescript.getFormat,
      transformSource = typescript.transformSource;
export { getFormat, resolve, transformSource, typescript };
//# sourceMappingURL=loader.mjs.map
