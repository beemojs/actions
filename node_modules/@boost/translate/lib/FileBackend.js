'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var common = require('@boost/common');

var TranslateError = require('./TranslateError.js');

const EXTS = {
  js: ['js'],
  json: ['json', 'json5'],
  yaml: ['yaml', 'yml']
};

class FileBackend extends common.Contract {
  constructor(...args) {
    super(...args);
    this.fileCache = new Map();
    this.type = 'backend';
  }

  init(services, options) {
    this.configure(options); // Validate resource paths are directories

    this.options.paths.forEach(path => {
      if (path.exists() && !path.isDirectory()) {
        throw new TranslateError.TranslateError('RESOURCE_PATH_INVALID', [path.path()]);
      }
    });
  }

  blueprint(predicates) {
    const array = predicates.array,
          instance = predicates.instance,
          string = predicates.string;
    return {
      format: string('yaml').oneOf(['js', 'json', 'yaml']),
      paths: array(instance(common.Path, true).notNullable())
    };
  } // istanbul ignore next


  create() {// We don't need this but is required by the interface
  }

  read(locale, namespace, handler) {
    const _this$options = this.options,
          format = _this$options.format,
          paths = _this$options.paths;
    const resources = {};
    paths.forEach(path => {
      EXTS[format].some(ext => {
        const resPath = path.append(locale, `${namespace}.${ext}`);
        const isCached = this.fileCache.has(resPath);

        if (!resPath.exists()) {
          return false;
        }

        if (!isCached) {
          this.fileCache.set(resPath, common.parseFile(resPath));
        }

        Object.assign(resources, this.fileCache.get(resPath));
        return true;
      });
    });
    handler(null, resources);
    return resources;
  }

}

exports.FileBackend = FileBackend;
//# sourceMappingURL=FileBackend.js.map
