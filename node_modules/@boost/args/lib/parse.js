'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var ArgsError = require('./ArgsError.js');

var Checker = require('./Checker.js');

var constants = require('./constants.js');

var debug = require('./debug.js');

var castValue = require('./helpers/castValue.js');

var createScope = require('./helpers/createScope.js');

var expandShortOption = require('./helpers/expandShortOption.js');

var formatValue = require('./helpers/formatValue.js');

var getDefaultValue = require('./helpers/getDefaultValue.js');

var isCommand = require('./helpers/isCommand.js');

var isLongOption = require('./helpers/isLongOption.js');

var isOptionLike = require('./helpers/isOptionLike.js');

var isShortOption = require('./helpers/isShortOption.js');

var isShortOptionGroup = require('./helpers/isShortOptionGroup.js');

var mapParserOptions = require('./helpers/mapParserOptions.js');

var processShortOptionGroup = require('./helpers/processShortOptionGroup.js');
/* eslint-disable complexity, no-continue */
// TERMINOLOGY
// command line - The entire line that encompasses the following parts.
// arg - Each type of argument (or part) passed on the command line, separated by a space.
// command - An optional "command" being ran that allows for branching functionality.
//    Sub-commands are separated with ":".
// option - An optional argument that requires a value(s). Starts with "--" (long) or "-" (short).
// flag - A specialized option that only supports booleans. Can be toggled on an off (default).
// param - An optional or required argument, that is not an option or option value,
//    Supports any raw value, and enforces a defined order.
// rest - All remaining arguments that appear after a stand alone "--".
//    Usually passed to subsequent scripts.
// scope - Argument currently being parsed.
// FEATURES
// Short name - A short name (single character) for an existing option or flag: --verbose, -v
// Option grouping - When multiple short options are passed under a single option: -abc
// Inline values - Option values that are immediately set using an equals sign: --foo=bar
// Group count - Increment a number each time a short option is found in a group: -vvv
// Arity count - Required number of argument values to consume for multiples.
// Choices - List of valid values to choose from. Errors otherwise.

/**
 * Parse a list of command line arguments (typically from `process.argv`) into an arguments
 * object. Will extract commands, options, flags, and params based on the defined parser options.
 */


function parse(argv, parserOptions) {
  const _parserOptions$comman = parserOptions.commands,
        commandConfigs = _parserOptions$comman === void 0 ? [] : _parserOptions$comman,
        _parserOptions$loose = parserOptions.loose,
        looseMode = _parserOptions$loose === void 0 ? false : _parserOptions$loose,
        optionConfigs = parserOptions.options,
        _parserOptions$params = parserOptions.params,
        paramConfigs = _parserOptions$params === void 0 ? [] : _parserOptions$params,
        _parserOptions$unknow = parserOptions.unknown,
        allowUnknown = _parserOptions$unknow === void 0 ? false : _parserOptions$unknow,
        _parserOptions$variad = parserOptions.variadic,
        allowVariadic = _parserOptions$variad === void 0 ? true : _parserOptions$variad;
  const checker = new Checker.Checker(optionConfigs);
  const options = {};
  const params = [];
  const rest = [];
  const unknown = {};
  const mapping = {};
  let command = '';
  let currentScope = null;
  debug.debug('Parsing arguments: %s', argv.join(' '));

  function commitScope() {
    if (!currentScope) {
      return;
    }

    const _currentScope = currentScope,
          name = _currentScope.name,
          value = _currentScope.value,
          finalValue = _currentScope.finalValue; // Support loose mode

    if (looseMode) {
      if (value === undefined) {
        options[name] = !currentScope.negated;
      } else {
        options[name] = finalValue;
      } // Set an unknown value

    } else if (currentScope.unknown) {
      if (allowUnknown) {
        unknown[name] = value === undefined ? constants.DEFAULT_STRING_VALUE : String(finalValue);
      } // Set and cast value if defined

    } else if (value !== undefined) {
      options[name] = finalValue;
    }

    currentScope = null;
  } // Run validations and map defaults


  checker.validateParamOrder(paramConfigs);
  mapParserOptions.mapParserOptions(parserOptions, options, params, {
    onCommand(cmd) {
      checker.validateCommandFormat(cmd);
    },

    onOption(config, value, name) {
      const short = config.short;

      if (short) {
        checker.validateUniqueShortName(name, short, mapping);
        mapping[short] = name;
      }

      options[name] = getDefaultValue.getDefaultValue(config);
      checker.validateDefaultValue(name, options[name], config);
      checker.validateNumberCount(name, config);
    },

    onParam(config) {
      checker.validateRequiredParamNoDefault(config);
    }

  }); // Process each argument

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    checker.arg = arg;
    checker.argIndex = i; // Rest arguments found, extract remaining and exit

    if (arg === '--') {
      rest.push(...argv.slice(i + 1));
      break;
    }

    try {
      // Options
      if (isOptionLike.isOptionLike(arg)) {
        let optionName = arg;
        let inlineValue; // Commit previous scope

        commitScope(); // Extract option and inline value

        if (optionName.includes('=')) {
          var _optionName$split = optionName.split('=', 2);

          var _optionName$split2 = _slicedToArray(_optionName$split, 2);

          optionName = _optionName$split2[0];
          inlineValue = _optionName$split2[1];
        } // Short option group "-frl"


        if (isShortOptionGroup.isShortOptionGroup(optionName)) {
          checker.checkNoInlineValue(inlineValue);
          processShortOptionGroup.processShortOptionGroup(optionName.slice(1), optionConfigs, options, mapping, looseMode);
          continue; // Short option "-f"
        } else if (isShortOption.isShortOption(optionName)) {
          optionName = expandShortOption.expandShortOption(optionName.slice(1), mapping, looseMode); // Long option "--foo"
        } else if (isLongOption.isLongOption(optionName)) {
          optionName = optionName.slice(2);
        } // Parse and create next scope


        const scope = createScope.createScope(optionName, optionConfigs, options); // Unknown option found, handle accordingly

        if (scope.unknown && !allowUnknown && !looseMode) {
          checker.checkUnknownOption(arg); // Flag found, so set value immediately and discard scope
        } else if (scope.flag) {
          options[scope.name] = !scope.negated;
          checker.checkNoInlineValue(inlineValue); // Otherwise keep scope open, to capture next value
        } else {
          currentScope = scope; // Update scope value if an inline value exists

          if (inlineValue !== undefined) {
            currentScope.captureValue(inlineValue, commitScope);
          }
        } // Option values

      } else if (currentScope) {
        currentScope.captureValue(arg, commitScope); // Commands
      } else if (isCommand.isCommand(arg, commandConfigs)) {
        checker.checkCommandOrder(arg, command, params.length);

        if (!command) {
          command = arg;
        } // Params

      } else if (paramConfigs[params.length]) {
        const config = paramConfigs[params.length];
        params.push(formatValue.formatValue(castValue.castValue(arg, config.type), config.format));
      } else if (allowVariadic) {
        params.push(arg);
      } else {
        throw new ArgsError.ArgsError('PARAM_UNKNOWN', [arg]);
      }
    } catch (error) {
      currentScope = null;
      checker.logFailure(error.message);
      continue;
    }
  } // Commit final scope


  commitScope(); // Fill missing params

  for (let i = params.length; i < paramConfigs.length; i += 1) {
    const config = paramConfigs[i];

    if (config.required) {
      break;
    }

    params.push(getDefaultValue.getDefaultValue(config));
  } // Run final checks


  mapParserOptions.mapParserOptions(parserOptions, options, params, {
    onOption(config, value, name) {
      checker.validateParsedOption(name, config, value);
      checker.validateArityIsMet(name, config, value);
      checker.validateChoiceIsMet(name, config, value); // Since default values avoid scope,
      // they are not cast. Do it manually after parsing.

      if (value === getDefaultValue.getDefaultValue(config)) {
        options[name] = castValue.castValue(value, config.type, config.multiple);
      }
    },

    onParam(config, value) {
      checker.validateParsedParam(config, value);
    }

  });
  return {
    command: command === '' ? [] : command.split(':'),
    errors: [...checker.parseErrors, ...checker.validationErrors],
    options: options,
    params: params,
    rest,
    unknown
  };
}

exports.parse = parse;
//# sourceMappingURL=parse.js.map
