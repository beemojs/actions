'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var os = require('os');

var debug = require('./debug.js');

var ParallelPipeline = require('./ParallelPipeline.js');

var PipelineError = require('./PipelineError.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var os__default = /*#__PURE__*/_interopDefault(os);
/* eslint-disable promise/prefer-await-to-callbacks */


class PooledPipeline extends ParallelPipeline.ParallelPipeline {
  constructor(...args) {
    super(...args);
    this.resolver = void 0;
    this.results = [];
    this.running = [];
  }

  blueprint(predicates) {
    const bool = predicates.bool,
          number = predicates.number;
    return {
      concurrency: number(os__default['default'].cpus().length).gte(1),
      filo: bool(),
      timeout: number(0).gte(0)
    };
  }
  /**
   * Execute all work units in parallel, in a pool with a max concurrency,
   * with a value being passed to each work unit.
   * Work units will synchronize regardless of race conditions and errors.
   */


  async run() {
    debug.debug('Running %d as a pool', this.work.length);
    this.onBeforeRun.emit([this.value]);
    const result = await new Promise(resolve => {
      if (this.work.length === 0) {
        resolve(this.aggregateResult([]));
        return;
      }

      this.resolver = resolve;
      void Promise.all(this.work.slice(0, this.options.concurrency).map(() => this.runWorkUnit(this.context, this.value)));
    });
    this.onAfterRun.emit([]);
    return result;
  }
  /**
   * Run a single work unit from the queue, and start the next work unit when it passes or fails.
   */


  async runWorkUnit(context, value) {
    const _this$options = this.options,
          concurrency = _this$options.concurrency,
          filo = _this$options.filo,
          timeout = _this$options.timeout;
    const unit = filo ? this.work.pop() : this.work.shift();
    this.running.push(unit);

    const handleResult = result => {
      this.running = this.running.filter(running => running !== unit);
      this.results.push(result);

      if (this.work.length > 0 && this.running.length < concurrency) {
        return this.runWorkUnit(context, value);
      }

      if (this.work.length === 0 && this.running.length === 0 && this.resolver) {
        this.resolver(this.aggregateResult(this.results));
      }

      return Promise.resolve();
    };

    return new Promise(resolve => {
      let timer;

      if (timeout > 0) {
        timer = setTimeout(() => {
          resolve(handleResult(new PipelineError.PipelineError('WORK_TIME_OUT')));
        }, timeout);
      }

      this.onRunWorkUnit.emit([unit, value]);
      unit.run(context, value).then(result => {
        if (timer) {
          clearTimeout(timer);
        }

        resolve(handleResult(result));
        return result;
      }).catch(error => {
        resolve(handleResult(error));
      });
    });
  }

}

exports.PooledPipeline = PooledPipeline;
//# sourceMappingURL=PooledPipeline.js.map
