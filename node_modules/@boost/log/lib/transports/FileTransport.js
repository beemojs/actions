'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var fs = require('fs');

var zlib = require('zlib');

var common = require('@boost/common');

var constants = require('../constants.js');

var Transport = require('../Transport.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var fs__default = /*#__PURE__*/_interopDefault(fs);

var zlib__default = /*#__PURE__*/_interopDefault(zlib);

class FileTransport extends Transport.Transport {
  constructor(options) {
    super(options);
    this.path = void 0;
    this.stream = void 0;
    this.buffer = '';
    this.draining = false;
    this.lastSize = 0;
    this.rotating = false;
    this.path = common.Path.resolve(this.options.path);
    this.checkFolderRequirements();
  }

  blueprint(predicates) {
    const bool = predicates.bool,
          instance = predicates.instance,
          union = predicates.union,
          number = predicates.number,
          string = predicates.string;
    return _objectSpread(_objectSpread({}, super.blueprint(predicates)), {}, {
      gzip: bool(),
      maxSize: number(constants.MAX_LOG_SIZE).positive(),
      path: union([string(), instance(common.Path)], '').required()
    });
  }
  /**
   * Close the file stream and trigger the callback when finished.
   */


  close(commit) {
    const onClose = () => {
      commit === null || commit === void 0 ? void 0 : commit();
      this.stream = undefined;
    };

    if (this.stream) {
      this.stream.once('finish', onClose).end();
    } else {
      onClose();
    }
  }
  /**
   * Open the file stream for writing.
   */


  open() {
    if (this.stream) {
      return this.stream;
    }

    this.stream = this.createStream();

    if (this.path.exists()) {
      this.lastSize = fs__default['default'].statSync(this.path.path()).size;
    }

    if (this.buffer) {
      const message = this.buffer;
      this.buffer = '';
      this.write(message);
    }

    return this.stream;
  }
  /**
   * Write a message to the file stream, and rotate files once written if necessary.
   */


  write(message) {
    if (this.rotating) {
      this.buffer += message;
      return;
    }

    const stream = this.open();
    const written = stream.write(message, 'utf8', () => {
      this.lastSize += Buffer.byteLength(message);
      this.checkIfNeedsRotation();
    }); // istanbul ignore next

    if (!written) {
      this.draining = true;
      stream.once('drain', () => {
        this.draining = false;
      });
    }
  }
  /**
   * Check that the parent folder exists and has the correct permissions.
   */


  checkFolderRequirements() {
    fs__default['default'].mkdirSync(this.path.parent().path(), {
      recursive: true
    });
  }
  /**
   * Check if we should change and rotate files because of max size.
   */


  checkIfNeedsRotation() {
    if (this.lastSize > this.options.maxSize) {
      this.closeStreamAndRotateFile();
    }
  }
  /**
   * Open and create a file stream for the defined path.
   * Apply file size and gzip checks.
   */


  createStream() {
    const stream = fs__default['default'].createWriteStream(this.path.path(), {
      encoding: 'utf8',
      flags: 'a'
    }); // Apply gzip compression to the stream

    if (this.options.gzip) {
      const gzip = zlib__default['default'].createGzip();
      gzip.pipe(stream);
      return gzip;
    }

    return stream;
  }
  /**
   * Return the file name with extension, of the newly rotated file.
   */


  getRotatedFileName() {
    return this.path.name();
  }
  /**
   * Count the number of files within path directory that matches the given file name.
   */


  getNextIncrementCount(name) {
    const files = fs__default['default'].readdirSync(this.path.parent().path());
    const pattern = new RegExp(`^${name}.\\d+$`, 'u');
    let count = 0;
    files.forEach(file => {
      if (file.match(pattern)) {
        count += 1;
      }
    });
    return count;
  }
  /**
   * Close the open stream and attempt to rotate the file.
   */


  closeStreamAndRotateFile() {
    // istanbul ignore next
    if (this.draining || this.rotating) {
      return;
    }

    this.rotating = true;
    this.close(() => {
      this.rotateFile();
      this.rotating = false;
    });
  }
  /**
   * Rotate the current file into a new file with an incremented name.
   */


  rotateFile() {
    let fileName = this.getRotatedFileName();

    if (this.options.gzip) {
      fileName += '.gz';
    }

    fileName += `.${this.getNextIncrementCount(fileName)}`;
    fs__default['default'].renameSync(this.path.path(), this.path.parent().append(fileName).path());
    this.lastSize = 0;
  }

}

exports.FileTransport = FileTransport;
//# sourceMappingURL=FileTransport.js.map
