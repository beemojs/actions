'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var os = require('os');

var util = require('util');

var common = require('@boost/common');

var internal = require('@boost/internal');

var constants = require('./constants.js');

var debug = require('./debug.js');

var Transport = require('./Transport.js');

var ConsoleTransport = require('./transports/ConsoleTransport.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var os__default = /*#__PURE__*/_interopDefault(os);

var util__default = /*#__PURE__*/_interopDefault(util);

class Logger extends common.Contract {
  constructor(options) {
    super(options);
    this.silent = false;
    const defaultLevel = internal.env('LOG_DEFAULT_LEVEL');
    const maxLevel = internal.env('LOG_MAX_LEVEL');
    debug.debug('New logger "%s" created: %s %s', this.options.name, defaultLevel ? `${defaultLevel} level` : 'all levels', maxLevel ? `(max ${maxLevel})` : '');
  }

  blueprint(predicates) {
    const array = predicates.array,
          instance = predicates.instance,
          object = predicates.object,
          string = predicates.string;
    return {
      labels: object(string()),
      metadata: object(),
      name: string().required().notEmpty(),
      transports: array(instance(Transport.Transport).notNullable(), [new ConsoleTransport.ConsoleTransport()])
    };
  }
  /**
   * Disable all logger messages from logging to the console.
   */


  disable() {
    debug.debug('Logger %s disabled', this.options.name);
    this.silent = true;
  }
  /**
   * Enable all logger messages to log the console.
   */


  enable() {
    debug.debug('Logger %s enabled', this.options.name);
    this.silent = false;
  }

  isAllowed(level, maxLevel) {
    if (!maxLevel) {
      return true;
    }

    for (const currentLevel of constants.LOG_LEVELS) {
      if (currentLevel === level) {
        return true;
      }

      if (currentLevel === maxLevel) {
        break;
      }
    }

    return false;
  }

  log(options) {
    var _ref, _ref2, _this$options$labels$;

    const _options$args = options.args,
          args = _options$args === void 0 ? [] : _options$args,
          level = options.level,
          message = options.message,
          _options$metadata = options.metadata,
          metadata = _options$metadata === void 0 ? {} : _options$metadata;
    const logLevel = (_ref = level !== null && level !== void 0 ? level : internal.env('LOG_DEFAULT_LEVEL')) !== null && _ref !== void 0 ? _ref : 'log';

    if (this.silent || !this.isAllowed(logLevel, internal.env('LOG_MAX_LEVEL'))) {
      return;
    }

    const item = {
      host: os__default['default'].hostname(),
      label: (_ref2 = (_this$options$labels$ = this.options.labels[logLevel]) !== null && _this$options$labels$ !== void 0 ? _this$options$labels$ : constants.DEFAULT_LABELS[logLevel]) !== null && _ref2 !== void 0 ? _ref2 : '',
      level: logLevel,
      message: util__default['default'].format(message, ...args),
      metadata: _objectSpread(_objectSpread({}, this.options.metadata), metadata),
      name: this.options.name,
      pid: process.pid,
      time: new Date()
    };
    this.options.transports.forEach(transport => {
      if (transport.levels.includes(item.level)) {
        void transport.write(transport.format(item), item);
      }
    });
  }

}

exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map
