'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var CommonError = require('./CommonError.js');

var Path = require('./Path.js');

var types = require('./types.js');

class PathResolver {
  constructor(resolver) {
    this.lookups = [];
    this.resolver = void 0;
    this.resolver = resolver !== null && resolver !== void 0 ? resolver : require.resolve;
  }
  /**
   * Return a list of all lookup paths.
   */


  getLookupPaths() {
    return this.lookups.map(lookup => lookup.path.path());
  }
  /**
   * Add a file system path to look for, resolved against the defined current
   * working directory (or `process.cwd()` otherwise).
   */


  lookupFilePath(filePath, cwd) {
    this.lookups.push({
      path: Path.Path.resolve(filePath, cwd),
      raw: Path.Path.create(filePath),
      type: types.LookupType.FILE_SYSTEM
    });
    return this;
  }
  /**
   * Add a Node.js module, either by name or relative path, to look for.
   */


  lookupNodeModule(modulePath) {
    const path = Path.Path.create(modulePath);
    this.lookups.push({
      path,
      raw: path,
      type: types.LookupType.NODE_MODULE
    });
    return this;
  }
  /**
   * Given a list of lookups, attempt to find the first real/existing path and
   * return a resolved absolute path. If a file system path, will check using `fs.exists`.
   * If a node module path, will check using `require.resolve`.
   */


  resolve() {
    let resolvedPath = '';
    let resolvedLookup;
    this.lookups.some(lookup => {
      // Check that the file exists on the file system.
      if (lookup.type === types.LookupType.FILE_SYSTEM) {
        if (lookup.path.exists()) {
          resolvedPath = lookup.path;
          resolvedLookup = lookup;
        } else {
          return false;
        } // Check that the module path exists using Node's module resolution.
        // The `require.resolve` function will throw an error if not found.

      } else if (lookup.type === types.LookupType.NODE_MODULE) {
        try {
          resolvedPath = this.resolver(lookup.path.path());
          resolvedLookup = lookup;
        } catch {
          return false;
        }
      }

      return true;
    });

    if (!resolvedPath || !resolvedLookup) {
      throw new CommonError.CommonError('PATH_RESOLVE_LOOKUPS', [this.lookups.map(lookup => `  - ${lookup.path} (${lookup.type})`).join('\n')]);
    }

    return {
      originalPath: resolvedLookup.raw,
      resolvedPath: Path.Path.create(resolvedPath),
      type: resolvedLookup.type
    };
  }
  /**
   * Like `resolve()` but only returns the resolved path.
   */


  resolvePath() {
    return this.resolve().resolvedPath;
  }

}

exports.PathResolver = PathResolver;
//# sourceMappingURL=PathResolver.js.map
