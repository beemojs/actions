'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var fs = require('fs');

var path = require('path');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var fs__default = /*#__PURE__*/_interopDefault(fs);

var path__default = /*#__PURE__*/_interopDefault(path);

class Path {
  constructor(...parts) {
    this.internalPath = ''; // Always use forward slashes for better interop

    this.internalPath = path__default['default'].normalize(path__default['default'].join(...parts.map(String))).replace(/\\/gu, Path.SEP);
  }
  /**
   * Create and return a new `Path` instance if a string.
   * If already a `Path`, return as is.
   */


  static create(filePath) {
    return filePath instanceof Path ? filePath : new Path(filePath);
  }
  /**
   * Like `create()` but also resolves the path against CWD.
   */


  static resolve(filePath, cwd) {
    return Path.create(filePath).resolve(cwd);
  }
  /**
   * Append path parts to the end of the current path
   * and return a new `Path` instance.
   */


  append(...parts) {
    return new Path(this.internalPath, ...parts);
  }
  /**
   * Returns true if both paths are equal using strict equality.
   */


  equals(filePath) {
    return this.path() === Path.create(filePath).path();
  }
  /**
   * Return the extension (if applicable) with or without leading period.
   */


  ext(withoutPeriod = false) {
    const ext = path__default['default'].extname(this.internalPath);
    return withoutPeriod && ext.startsWith('.') ? ext.slice(1) : ext;
  }
  /**
   * Return true if the current path exists.
   */


  exists() {
    return fs__default['default'].existsSync(this.internalPath);
  }
  /**
   * Return true if the current path is absolute.
   */


  isAbsolute() {
    return path__default['default'].isAbsolute(this.internalPath);
  }
  /**
   * Return true if the current path is a folder.
   */


  isDirectory() {
    return fs__default['default'].statSync(this.internalPath).isDirectory();
  }
  /**
   * Return true if the current path is a file.
   */


  isFile() {
    return fs__default['default'].statSync(this.internalPath).isFile();
  }
  /**
   * Return the file name (with optional extension) or folder name.
   */


  name(withoutExtension = false) {
    let name = path__default['default'].basename(this.internalPath);

    if (withoutExtension) {
      name = name.replace(this.ext(), '');
    }

    return name;
  }
  /**
   * Return the parent folder as a new `Path` instance.
   */


  parent() {
    return new Path(path__default['default'].dirname(this.internalPath));
  }
  /**
   * Return the current path as a normalized string.
   */


  path() {
    return this.internalPath;
  }
  /**
   * Prepend path parts to the beginning of the current path
   * and return a new `Path` instance.
   */


  prepend(...parts) {
    return new Path(...parts, this.internalPath);
  }
  /**
   * Returns a canonical path by resolving directories and symlinks.
   */
  // istanbul ignore next


  realPath() {
    return fs__default['default'].realpathSync.native(this.path());
  }
  /**
   * Return a new relative `Path` instance from the current
   * "from" path to the defined "to" path.
   */


  relativeTo(to) {
    return new Path(path__default['default'].relative(this.path(), String(to)));
  }
  /**
   * Return a new `Path` instance where the current path is accurately
   * resolved against the defined current working directory.
   */


  resolve(cwd) {
    return new Path(path__default['default'].resolve(String(cwd !== null && cwd !== void 0 ? cwd : process.cwd()), this.internalPath));
  }

  toJSON() {
    return this.path();
  }

  toString() {
    return this.path();
  }

}

Path.DELIMITER = path__default['default'].delimiter;
Path.SEP = '/';
exports.Path = Path;
//# sourceMappingURL=Path.js.map
