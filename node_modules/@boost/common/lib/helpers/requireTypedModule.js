'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var fs = require('fs');

var interopRequireModule = require('../internal/interopRequireModule.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var fs__default = /*#__PURE__*/_interopDefault(fs);
/* eslint-disable no-underscore-dangle, node/no-deprecated-api */


let ts = null;

try {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  ts = require('typescript');
} catch {// Ignore and check at runtime
}

const transformCache = new Map();

function transform(contents, fileName) {
  if (!ts) {
    throw new Error(`\`typescript\` package required for importing file "${fileName}".`);
  }

  return ts.transpileModule(contents, {
    compilerOptions: {
      allowJs: true,
      allowSyntheticDefaultImports: true,
      esModuleInterop: true,
      module: ts.ModuleKind.CommonJS,
      noEmit: true,
      resolveJsonModule: true,
      target: ts.ScriptTarget.ES2016
    },
    fileName
  }).outputText;
}

function transformHandler(mod, filePath) {
  let code = transformCache.get(filePath);

  if (!code) {
    code = transform(fs__default['default'].readFileSync(filePath, 'utf8'), filePath);
    transformCache.set(filePath, code);
  }

  mod._compile(code, filePath);
} // https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L1103
// https://github.com/TypeStrong/ts-node/blob/master/src/index.ts#L1071


function registerExtensions() {
  require.extensions['.ts'] = transformHandler;
  require.extensions['.tsx'] = transformHandler;
}

function unregisterExtensions() {
  delete require.extensions['.ts'];
  delete require.extensions['.tsx'];
}
/**
 * Like `requireModule` but for importing TypeScript files ending in `ts` or `tsx`.
 * When imported, will transform the file using the `typescript` package (must be installed),
 * evaluate the code in the current module context, and apply the same process to all child imports.
 *
 * ```ts
 * import { requireTypedModule } from '@boost/common';
 *
 * const result: ReturnShape = requireTypedModule('../../some/module.ts');
 * ```
 *
 * > This helper rarely needs to be used directly as `parseFile` and `requireModule` will
 * > call it under the hood based on the file extension.
 */


function requireTypedModule(path) {
  const filePath = String(path);

  if (!filePath.endsWith('.ts') && !filePath.endsWith('.tsx')) {
    throw new Error(`Unable to import non-TypeScript file "${filePath}", use \`requireModule\` instead.`);
  }

  registerExtensions();
  const result = interopRequireModule.interopRequireModule(filePath);
  unregisterExtensions();
  return result;
}

exports.requireTypedModule = requireTypedModule;
//# sourceMappingURL=requireTypedModule.js.map
