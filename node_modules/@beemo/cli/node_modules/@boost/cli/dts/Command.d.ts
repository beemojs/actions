import React from 'react';
import execa, { Options as ExecaOptions } from 'execa';
import { ArgList, Arguments, Argv, OptionConfigMap, ParamConfigList, ParserOptions, PrimitiveType, UnknownOptionMap } from '@boost/args';
import { Blueprint, Predicates } from '@boost/common';
import { LoggerFunction } from '@boost/log';
import { CommandManager } from './CommandManager';
import { INTERNAL_OPTIONS, INTERNAL_PARAMS, INTERNAL_PROGRAM } from './constants';
import { Program } from './Program';
import { Categories, Commandable, CommandMetadata, CommandPath, ExitCode, ExitHandler, GlobalOptions, ProxyCommandConfig, ProxyCommandRunner, RunResult, TaskContext } from './types';
/**
 * Create a proxy command using itself as the super class.
 */
export declare function createProxyCommand<O extends GlobalOptions, P extends PrimitiveType[]>(path: CommandPath, proxyConfig: ProxyCommandConfig<O, P>, runner: ProxyCommandRunner<O, P>): Command<O, P>;
export declare abstract class Command<O extends GlobalOptions = GlobalOptions, P extends PrimitiveType[] = ArgList, Options extends object = {}> extends CommandManager<Options> implements Commandable<O, P> {
    static aliases: string[];
    static allowUnknownOptions: boolean;
    static allowVariadicParams: boolean | string;
    static categories: Categories;
    static category: string;
    static description: string;
    static deprecated: boolean;
    static hidden: boolean;
    static options: OptionConfigMap;
    static params: ParamConfigList;
    static path: string;
    static usage: string[] | string;
    /** Value of `--help`, `-h` passed on the command line. */
    help: boolean;
    /** Value of `--locale` passed on the command line. */
    locale: string;
    /** Additional arguments passed after `--` on the command line. */
    rest: string[];
    /** Unknown options passed on the command line. */
    unknown: UnknownOptionMap;
    /** Value of `--version`, `-v` passed on the command line. */
    version: boolean;
    /** Method to exit the current program, with an optional error code. */
    exit: ExitHandler;
    /** Method to log to the console using a log level. */
    log: LoggerFunction;
    /** @internal */
    [INTERNAL_OPTIONS]?: O;
    /** @internal */
    [INTERNAL_PARAMS]?: P;
    /** @internal */
    [INTERNAL_PROGRAM]?: Program;
    constructor(options?: Options);
    /**
     * Validate options passed to the constructor.
     */
    blueprint(predicates: Predicates): Blueprint<object>;
    /**
     * Create a React element based on the Help component.
     */
    createHelp(): Promise<React.ReactElement>;
    /**
     * Execute a system native command with the given arguments
     * and pass the results through a promise. This does *not* execute Boost CLI
     * commands, use `runProgram()` instead.
     */
    executeCommand(command: string, args: string[], options?: ExecaOptions): execa.ExecaChildProcess<string>;
    /**
     * Return the current command class as an arguments object.
     * Options and params must be parsed first to operate correctly.
     */
    getArguments(): Arguments<O, P>;
    /**
     * Validate and return all metadata registered to this command instance.
     */
    getMetadata(): CommandMetadata;
    /**
     * Return metadata as options for argument parsing.
     */
    getParserOptions(): ParserOptions<O, P>;
    /**
     * Return the command path (canonical name on the command line).
     */
    getPath(): string;
    /**
     * Render a React element with Ink and output to the configured streams.
     */
    render(element: React.ReactElement): Promise<void>;
    /**
     * Run the program within itself, by passing a custom command and argv list.
     */
    runProgram: (argv: Argv) => Promise<ExitCode>;
    /**
     * Run a task (function) with the defined arguments and
     * the current command instance bound to the task's context.
     */
    runTask: <A extends unknown[], R>(task: (this: TaskContext<O>, ...args: A) => R, ...args: A) => R;
    /**
     * Executed when the command is being ran.
     */
    abstract run(...params: P): Promise<RunResult> | RunResult;
    /**
     * Create a proxy command using itself as the super class.
     */
    protected createProxyCommand<PO extends GlobalOptions, PP extends PrimitiveType[]>(path: CommandPath, config: ProxyCommandConfig<PO, PP>, runner: ProxyCommandRunner<PO, PP>): Command<PO, PP>;
    /**
     * Return the program instance or fail.
     */
    private getProgram;
    /**
     * Verify sub-command is prefixed with the correct path.
     */
    private handleBeforeRegister;
}
//# sourceMappingURL=Command.d.ts.map