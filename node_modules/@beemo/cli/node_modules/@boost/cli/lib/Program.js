'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var React = require('react');

var ink = require('ink');

var levenary = require('levenary');

var args = require('@boost/args');

var common = require('@boost/common');

var event = require('@boost/event');

var internal = require('@boost/internal');

var log = require('@boost/log');

var CLIError = require('./CLIError.js');

var Command = require('./Command.js');

var CommandManager = require('./CommandManager.js');

var constants = require('./constants.js');

var isArgvSize = require('./helpers/isArgvSize.js');

var mapCommandMetadata = require('./helpers/mapCommandMetadata.js');

var patchDebugModule = require('./helpers/patchDebugModule.js');

var LogBuffer = require('./LogBuffer.js');

var getConstructor = require('./metadata/getConstructor.js');

var removeProcessBin = require('./middleware/removeProcessBin.js');

var translate = require('./translate.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var React__default = /*#__PURE__*/_interopDefault(React);

var levenary__default = /*#__PURE__*/_interopDefault(levenary);

class Program extends CommandManager.CommandManager {
  /**
   * Called after a component has rendered.
   * @category Events
   */

  /**
   * Called after the program and command have been ran.
   * @category Events
   */

  /**
   * Called after a command has run but before a component will render.
   * @category Events
   */

  /**
   * Called before the program and command will run.
   * @category Events
   */

  /**
   * Called when a command has been found after parsing argv.
   * @category Events
   */

  /**
   * Called when a command wasn't found after parsing argv.
   * @category Events
   */

  /**
   * Called when the exit() handler is executed but before the process exits.
   * @category Events
   */

  /**
   * Called when the help menu is rendered.
   * @category Events
   */
  constructor(options, streams) {
    super(options);
    this.onAfterRender = new event.Event('after-render');
    this.onAfterRun = new event.Event('after-run');
    this.onBeforeRender = new event.Event('before-render');
    this.onBeforeRun = new event.Event('before-run');
    this.onCommandFound = new event.Event('command-found');
    this.onCommandNotFound = new event.Event('command-not-found');
    this.onExit = new event.Event('exit');
    this.onHelp = new event.Event('help');
    this.streams = {
      stderr: process.stderr,
      stdin: process.stdin,
      stdout: process.stdout
    };
    this.commandLine = '';
    this.logger = void 0;
    this.middlewares = [removeProcessBin.removeProcessBin()];
    this.rendering = false;
    this.sharedCategories = {
      global: {
        name: translate.msg('cli:categoryGlobal'),
        weight: 100
      }
    };
    this.standAlone = '';
    this.errBuffer = void 0;
    this.outBuffer = void 0;

    this.exit = (error, errorCode) => {
      let message = '';
      let code = errorCode;

      if (error instanceof common.ExitError) {
        message = error.message;
        code = error.code;
      } else if (error instanceof Error) {
        message = error.message;
      } else if (error) {
        message = error;
      }

      if (!code) {
        code = message ? constants.EXIT_FAIL : constants.EXIT_PASS;
      }

      this.onExit.emit([message, code]);
      throw new common.ExitError(message, code);
    };

    this.handleAfterRegister = (_path, command) => {
      const deepRegister = cmd => {
        const _cmd$getMetadata = cmd.getMetadata(),
              aliases = _cmd$getMetadata.aliases,
              commands = _cmd$getMetadata.commands,
              path = _cmd$getMetadata.path;

        this.commands[path] = cmd;
        aliases.forEach(alias => {
          this.commandAliases[alias] = path;
        });
        Object.values(commands).forEach(deepRegister);
      };

      deepRegister(command);
    };

    this.handleBeforeRegister = () => {
      if (this.standAlone) {
        throw new CLIError.CLIError('COMMAND_MIXED_DEFAULT');
      }
    };

    Object.assign(this.streams, streams); // Buffers logs during the Ink rendering process

    this.errBuffer = new LogBuffer.LogBuffer(this.streams.stderr);
    this.outBuffer = new LogBuffer.LogBuffer(this.streams.stdout); // Both logger and global console will write to the buffers

    this.logger = log.createLogger({
      name: 'cli',
      transports: [new log.StreamTransport({
        format: log.formats.console,
        levels: ['error', 'trace', 'warn'],
        stream: this.errBuffer
      }), new log.StreamTransport({
        format: log.formats.console,
        levels: ['debug', 'info', 'log'],
        stream: this.outBuffer
      })]
    });
    this.onAfterRegister.listen(this.handleAfterRegister);
    this.onBeforeRegister.listen(this.handleBeforeRegister);
  }

  blueprint(predicates) {
    const string = predicates.string;
    return {
      banner: string(),
      bin: string().notEmpty().required().kebabCase(),
      delimiter: string(constants.DELIMITER),
      footer: string(),
      header: string(),
      name: string().notEmpty().required(),
      version: string().required().match(constants.VERSION_FORMAT)
    };
  }
  /**
   * Define option and command categories to supply to the running command,
   * or the program itself.
   */


  categories(categories) {
    Object.assign(this.sharedCategories, categories);
    return this;
  }
  /**
   * Register a command and its canonical path as the default command.
   * A default command should be used when stand-alone binary is required.
   */


  default(command) {
    if (Object.keys(this.commands).length > 0) {
      throw new CLIError.CLIError('COMMAND_MIXED_NONDEFAULT');
    }

    this.register(command);
    this.standAlone = command.getPath();
    return this;
  }
  /**
   * Exit the program with an error code.
   * Should be called within a command or component.
   */

  /**
   * Define a middleware function to apply to the argv list or args object.
   */


  middleware(middleware) {
    if (typeof middleware !== 'function') {
      throw new CLIError.CLIError('MIDDLEWARE_INVALID');
    }

    this.middlewares.push(middleware);
    return this;
  }
  /**
   * Parse the arguments list according to the number of commands that have been registered.
   */


  parse(argv) {
    if (Object.keys(this.commands).length === 0) {
      throw new CLIError.CLIError('COMMAND_NONE_REGISTERED');
    }

    if (this.standAlone) {
      return args.parse(argv, this.getCommand(this.standAlone).getParserOptions());
    }

    try {
      return args.parseInContext(argv, arg => {
        var _this$getCommand;

        return (_this$getCommand = this.getCommand(arg)) === null || _this$getCommand === void 0 ? void 0 : _this$getCommand.getParserOptions();
      });
    } catch {
      var _argv$find;

      const possibleCmd = (_argv$find = argv.find(arg => !arg.startsWith('-'))) !== null && _argv$find !== void 0 ? _argv$find : '';
      this.onCommandNotFound.emit([argv, possibleCmd]);

      if (possibleCmd) {
        const closestCmd = levenary__default['default'](possibleCmd, this.getCommandPaths());
        throw new CLIError.CLIError('COMMAND_UNKNOWN', [possibleCmd, closestCmd]);
      }

      throw new CLIError.CLIError('COMMAND_INVALID_RUN');
    }
  }
  /**
   * Render a React element with Ink and output to the configured streams.
   */


  async renderElement(element) {
    // Do not allow nested renders
    // istanbul ignore next
    if (this.rendering) {
      throw new CLIError.CLIError('REACT_RENDER_NO_NESTED');
    } else {
      this.rendering = true;
    }

    const _await$Promise$resolv = await Promise.resolve().then(function () {
      return require('./components/internal/Wrapper.js');
    }),
          Wrapper = _await$Promise$resolv.Wrapper;

    const _this$streams = this.streams,
          stdin = _this$streams.stdin,
          stdout = _this$streams.stdout,
          stderr = _this$streams.stderr;
    const unpatchDebug = patchDebugModule.patchDebugModule();

    try {
      this.onBeforeRender.emit([element]);
      const output = await ink.render( /*#__PURE__*/React__default['default'].createElement(Wrapper, {
        errBuffer: this.errBuffer,
        exit: this.exit,
        log: this.logger,
        outBuffer: this.outBuffer,
        program: this.options
      }, element), {
        debug: process.env.NODE_ENV === 'test',
        exitOnCtrlC: true,
        experimental: true,
        patchConsole: true,
        stderr,
        stdin,
        stdout
      }); // This never resolves while testing
      // istanbul ignore next

      if (!internal.env('CLI_TEST_ONLY')) {
        await output.waitUntilExit();
      }

      this.onAfterRender.emit([]);
    } catch (error) {
      // Never runs while testing
      // istanbul ignore next
      this.exit(error);
    } finally {
      this.rendering = false;
      unpatchDebug();
    }
  }
  /**
   * Run the program in the following steps:
   * - Apply middleware to argv list.
   * - Parse argv into an args object (of options, params, etc).
   * - Determine command to run, or fail.
   * - Run command and render output.
   * - Return exit code.
   */


  async run(argv, bootstrap, rethrow = false) {
    this.onBeforeRun.emit([argv]);
    let exitCode = 0;

    try {
      if (bootstrap) {
        await bootstrap();
      }

      exitCode = await this.runAndRender(argv);
      this.onAfterRun.emit([]);
    } catch (error) {
      if (error instanceof Error) {
        exitCode = await this.renderErrors([error]);
        this.onAfterRun.emit([error]);

        if (rethrow) {
          throw error;
        }
      }
    }

    return exitCode;
  }
  /**
   * Run the program and also set the process exit code.
   */
  // istanbul ignore next


  async runAndExit(argv, bootstrap) {
    const exitCode = await this.run(argv, bootstrap);
    process.exitCode = exitCode;
    return exitCode;
  }
  /**
   * Render the index screen when no args are passed.
   * Should include banner, header, footer, and command (if applicable).
   */


  async createIndex() {
    const _await$Promise$resolv2 = await Promise.resolve().then(function () {
      return require('./components/IndexHelp.js');
    }),
          IndexHelp = _await$Promise$resolv2.IndexHelp;

    if (this.standAlone) {
      return /*#__PURE__*/React__default['default'].createElement(IndexHelp, this.options, await this.getCommand(this.standAlone).createHelp());
    }

    const commands = {}; // Remove sub-commands

    Object.entries(this.commands).forEach(([path, command]) => {
      if (!path.includes(':')) {
        commands[path] = command;
      }
    });

    const _await$Promise$resolv3 = await Promise.resolve().then(function () {
      return require('./components/Help.js');
    }),
          Help = _await$Promise$resolv3.Help;

    return /*#__PURE__*/React__default['default'].createElement(IndexHelp, this.options, /*#__PURE__*/React__default['default'].createElement(Help, {
      categories: this.sharedCategories,
      commands: mapCommandMetadata.mapCommandMetadata(commands),
      delimiter: this.options.delimiter,
      header: translate.msg('cli:labelAbout')
    }));
  }
  /**
   * Loop through all middleware to modify the argv list
   * and resulting args object.
   */


  applyMiddlewareAndParseArgs(argv) {
    let index = -1;

    const next = nextArgv => {
      index += 1;
      const middleware = this.middlewares[index]; // Keep calling middleware until we exhaust them all

      if (middleware) {
        return middleware(nextArgv, next, this.logger);
      } // Otherwise all middleware have ran, so parse the final list


      this.commandLine = nextArgv.join(' ');
      return this.parse(nextArgv);
    };

    return next(argv);
  }
  /**
   * Create a proxy command using the `Command` class as the super class.
   */


  createProxyCommand(path, config, runner) {
    return Command.createProxyCommand(path, config, runner);
  }
  /**
   * Render the result of a command's run to the defined stream.
   * If a string has been returned, write it immediately.
   * If a React component, render with Ink and wait for it to finish.
   */


  async render(result, exitCode = constants.EXIT_PASS) {
    // For simple strings, ignore react and the buffer
    if (typeof result === 'string') {
      this.streams.stdout.write(`${result}\n`);
      return exitCode;
    }

    if (result) {
      await this.renderElement(result);
    }

    return exitCode;
  }
  /**
   * Render an error and warnings menu based on the list provided.
   * If argument parser or validation errors are found, treat them with special logic.
   */


  async renderErrors(errors) {
    var _ref, _parseErrors$;

    const exitError = errors[0];

    if (exitError instanceof common.ExitError && exitError.code === 0) {
      return Promise.resolve(exitError.code);
    } // eslint-disable-next-line unicorn/prefer-array-find


    const parseErrors = errors.filter(error => error instanceof args.ParseError);
    const validErrors = errors.filter(error => error instanceof args.ValidationError);
    const error = (_ref = (_parseErrors$ = parseErrors[0]) !== null && _parseErrors$ !== void 0 ? _parseErrors$ : validErrors[0]) !== null && _ref !== void 0 ? _ref : exitError; // Mostly for testing, but useful for other things
    // istanbul ignore next

    if (internal.env('CLI_TEST_FAIL_HARD')) {
      throw error;
    }

    const _await$Promise$resolv4 = await Promise.resolve().then(function () {
      return require('./components/Failure.js');
    }),
          Failure = _await$Promise$resolv4.Failure;

    return this.render( /*#__PURE__*/React__default['default'].createElement(Failure, {
      binName: this.options.bin,
      commandLine: this.commandLine,
      delimiter: this.options.delimiter,
      error: error,
      warnings: validErrors.filter(verror => verror !== error)
    }), error instanceof common.ExitError ? error.code : constants.EXIT_FAIL);
  }
  /**
   * Internal run that does all the heavy lifting and parsing,
   * while the public run exists to catch any unexpected errors.
   */


  async runAndRender(argv) {
    const showVersion = argv.some(arg => arg === '-v' || arg === '--version');
    const showHelp = argv.some(arg => arg === '-h' || arg === '--help'); // Display index help

    if (isArgvSize.isArgvSize(argv, 0) && !this.standAlone || isArgvSize.isArgvSize(argv, 1) && showHelp) {
      this.onHelp.emit([]);
      return this.render(await this.createIndex());
    } // Display version


    if (showVersion) {
      return this.render(this.options.version);
    } // Parse the arguments


    const _await$this$applyMidd = await this.applyMiddlewareAndParseArgs(argv),
          paths = _await$this$applyMidd.command,
          errors = _await$this$applyMidd.errors,
          options = _await$this$applyMidd.options,
          params = _await$this$applyMidd.params,
          rest = _await$this$applyMidd.rest,
          unknown = _await$this$applyMidd.unknown;

    const path = paths.join(':') || this.standAlone;
    const command = this.getCommand(path);
    this.onCommandFound.emit([argv, path, command]); // Apply shared categories to command constructor

    Object.assign(getConstructor.getConstructor(command).categories, this.sharedCategories); // Display command help

    if (options.help) {
      this.onHelp.emit([path]);
      return this.render(await command.createHelp());
    } // Display errors


    if (errors.length > 0) {
      return this.renderErrors(errors);
    } // Apply options to command properties


    Object.assign(command, options); // Apply remaining arguments and properties

    command.rest = rest;
    command.unknown = unknown;
    command.exit = this.exit;
    command.log = this.logger;
    command[constants.INTERNAL_OPTIONS] = options;
    command[constants.INTERNAL_PARAMS] = params;
    command[constants.INTERNAL_PROGRAM] = this;
    return this.render(await command.run(...params));
  }
  /**
   * Deeply register all commands so that we can easily access it during parse.
   */


}

exports.Program = Program;
//# sourceMappingURL=Program.js.map
