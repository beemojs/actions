'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var ink = require('ink');

var internal = require('@boost/internal');

var test = require('@boost/log/test');

var terminal = require('@boost/terminal');

require('./index.js');

var Program = require('./Program.js');

var constants = require('./constants.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);

  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }

  n['default'] = e;
  return Object.freeze(n);
}
/* eslint-disable no-param-reassign, jest/prefer-spy-on */


class MockReadStream {
  constructor() {
    this.isTTY = false;
  }

}

class MockWriteStream {
  constructor(append = false) {
    this.append = false;
    this.columns = 80;
    this.output = void 0;
    this.append = append;
    this.output = '';
  }

  write(string) {
    if (this.append) {
      this.output += string;
    } else {
      this.output = string;
    }
  }

  get() {
    return this.output;
  }

  on() {}

  off() {}

}
/**
 * Returns mocked `stderr`, `stdout`, and `stdin` streams that can be passed to a `Program`.
 * This does not mock all stream functionality, only those required by Boost and Ink.
 *
 * ```ts
 * import { mockStreams } from '@boost/cli/test';
 *
 * const streams = mockStreams();
 * ```
 */


function mockStreams(append) {
  return {
    stderr: new MockWriteStream(append),
    stdin: new MockReadStream(),
    stdout: new MockWriteStream(append)
  };
}
/**
 * Returns a `Program` instance with required options pre-filled and streams mocked
 * (unless manually provided).
 *
 * ```ts
 * import { mockProgram } from '@boost/cli/test';
 *
 * const program = mockProgram({ name: 'Example' });
 * ```
 */


function mockProgram(options, streams) {
  return new Program.Program(_objectSpread({
    bin: 'test',
    name: 'Test',
    version: '0.0.0'
  }, options), streams !== null && streams !== void 0 ? streams : mockStreams());
}
/**
 * Can be used to render a React component with Ink and return the rendered result
 * as a terminal compatible string. If `stripped` is true, it will strip ANSI
 * escape escape sequences.
 *
 * ```tsx
 * import { renderComponent } from '@boost/cli/test';
 * import TestComponent from '../src/components/TestComponent';
 *
 * it('renders a component', async () => {
 * 	expect(await renderComponent(<TestComponent />)).toMatchSnapshot();
 * });
 * ```
 *
 * > As an alternative, we also suggest using the official
 * > [ink-testing-library](https://github.com/vadimdemedes/ink-testing-library).
 */


async function renderComponent(element, stripped = false) {
  let output = '';

  try {
    var _lastFrame;

    const _await$Promise$resolv = await Promise.resolve().then(function () {
      return /*#__PURE__*/_interopNamespace(require('ink-testing-library'));
    }),
          renderAsTest = _await$Promise$resolv.render;

    const _await$renderAsTest = await renderAsTest(element),
          lastFrame = _await$renderAsTest.lastFrame;

    output = (_lastFrame = lastFrame()) !== null && _lastFrame !== void 0 ? _lastFrame : '';
  } catch {
    const stdout = new MockWriteStream();
    await ink.render(element, {
      debug: true,
      experimental: true,
      stdout: stdout
    });
    output = stdout.get();
  }

  return stripped ? terminal.stripAnsi(output) : output;
}
/**
 * Runs a `Command` outside the context of a `Program`, but mimics similar functionality,
 * including React component rendering. Params are required as they're passed to the run method,
 * while options are optional and assume class properties have been defined. Also, the `exit`
 * and `log` methods have been mocked with Jest spies so that they can be asserted.
 *
 * ```ts
 * import { runCommand } from '@boost/cli/test';
 * import TestCommand from '../src/commands/TestCommand';
 *
 * it('runs a command', async () => {
 * 	const command = new TestCommand();
 *
 * 	expect(await runCommand(command, ['foo', 'bar', 'baz'])).toMatchSnapshot();
 * 	expect(command.log).toHaveBeenCalled();
 * });
 * ```
 *
 * > Since there is no `Program` context, any functionality that requires a program will fail. If
 * > needed, use `runProgram()` instead.
 */


async function runCommand(command, params, options) {
  if (options) {
    Object.assign(command, options); // @ts-expect-error Allow overwrite

    command[constants.INTERNAL_OPTIONS] = _objectSpread({
      help: false,
      locale: 'en',
      version: false
    }, options);
  }

  command.exit = jest.fn();
  command.log = test.mockLogger();
  command[constants.INTERNAL_PARAMS] = params;
  const result = await command.run(...params);

  if (!result || typeof result === 'string') {
    return result !== null && result !== void 0 ? result : '';
  }

  return renderComponent(result);
}
/**
 * Runs a task function outside the context of a `Command`, in complete isolation.
 * A mock command context is provided with standard defaults, and can be customized
 * through the 3rd argument.
 *
 * ```ts
 * import { runTask } from '@boost/cli/test';
 * import testTask from '../src/tasks/testTask';
 *
 * it('runs a task', async () => {
 * 	const context = {
 * 		log: jest.fn(),
 * 	};
 *
 * 	expect(await runTask(testTask, ['foo', 'bar', 'baz'], context)).toMatchSnapshot();
 * 	expect(context.log).toHaveBeenCalled();
 * });
 * ```
 */


function runTask(task, args, context) {
  const notTestable = name => () => {
    throw new Error(`\`${name}\` is not testable using the \`runTask\` utility. Test using a full program.`);
  };

  const baseContext = {
    exit: jest.fn(),
    help: false,
    locale: 'en',
    log: test.mockLogger(),
    rest: [],
    runProgram: notTestable('runProgram'),
    runTask: notTestable('runTask'),
    unknown: {},
    version: false
  };
  return task.apply(_objectSpread(_objectSpread({}, baseContext), context), args);
}
/**
 * Runs a `Program` as if it were ran on the command line, including middleware,
 * commands, success and failure states, and more. Utilizes mocked streams to capture
 * and return standard output and ANSI stripped output. Failed runs will not throw
 * and instead will render a failure output.
 *
 * ```ts
 * import { runProgram } from '@boost/cli/test';
 * import Program from '../src/program';
 *
 * it('runs a program', async () => {
 * 	const program = new Program();
 *
 * 	const { code, output } = await runProgram(program, ['cmd', '--foo', '123', 'bar']);
 *
 * 	expect(output).toMatchSnapshot();
 * 	expect(code).toBe(0);
 * });
 * ```
 */


async function runProgram(program, argv, options = {}) {
  if (!(program.streams.stderr instanceof MockWriteStream)) {
    program.streams.stderr = new MockWriteStream(options.append);
  }

  if (!(program.streams.stdout instanceof MockWriteStream)) {
    program.streams.stdout = new MockWriteStream(options.append);
  }

  if (!(program.streams.stdin instanceof MockReadStream)) {
    program.streams.stdin = new MockReadStream();
  } // Ink async rendering never resolves while testing,
  // as it relies on system signals to "exit".
  // So we set this to flag the renderer to avoid awaiting.


  internal.env('CLI_TEST_ONLY', 'true');
  const code = await program.run(argv);
  internal.env('CLI_TEST_ONLY', null);
  const output = program.streams.stdout.get() + program.streams.stderr.get();
  return {
    code,
    output,
    outputStripped: terminal.stripAnsi(output)
  };
}

exports.MockReadStream = MockReadStream;
exports.MockWriteStream = MockWriteStream;
exports.mockProgram = mockProgram;
exports.mockStreams = mockStreams;
exports.renderComponent = renderComponent;
exports.runCommand = runCommand;
exports.runProgram = runProgram;
exports.runTask = runTask;
//# sourceMappingURL=test.js.map
