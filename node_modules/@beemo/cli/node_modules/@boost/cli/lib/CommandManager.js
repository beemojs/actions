'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var common = require('@boost/common');

var event = require('@boost/event');

var CLIError = require('./CLIError.js');

class CommandManager extends common.Contract {
  constructor(...args) {
    super(...args);
    this.onAfterRegister = new event.Event('after-register');
    this.onBeforeRegister = new event.Event('before-register');
    this.commands = {};
    this.commandAliases = {};
  }
  /**
   * Return a command by registered path, or `null` if not found.
   */


  getCommand(path) {
    if (!path) {
      return null;
    }

    const alias = this.commandAliases[path];
    return alias && this.commands[alias] || this.commands[path] || null;
  }
  /**
   * Return a list of all registered command paths (including aliases).
   */


  getCommandPaths() {
    return [...Object.keys(this.commands), ...Object.keys(this.commandAliases)];
  }
  /**
   * Register a command and its canonical path (must be unique),
   * otherwise an error is thrown.
   */


  register(commandOrPath, config, runner) {
    let command;

    if (typeof commandOrPath === 'string' && typeof config !== 'undefined' && typeof runner === 'function') {
      command = this.createProxyCommand(commandOrPath, config, runner);
    } else if (common.isObject(commandOrPath) && typeof commandOrPath.run === 'function') {
      command = commandOrPath;
    } else {
      throw new CLIError.CLIError('COMMAND_INVALID_REGISTER');
    }

    const _command$getMetadata = command.getMetadata(),
          aliases = _command$getMetadata.aliases,
          path = _command$getMetadata.path;

    this.onBeforeRegister.emit([path, command]);
    this.checkPath(path);
    this.commands[path] = command;
    aliases.forEach(alias => {
      this.checkPath(alias);
      this.commandAliases[alias] = path;
    });
    this.onAfterRegister.emit([path, command]);
    return this;
  }
  /**
   * Check that a command path is valid.
   */


  checkPath(path) {
    if (this.commands[path]) {
      throw new CLIError.CLIError('COMMAND_DEFINED', [path]);
    }
  }

}

exports.CommandManager = CommandManager;
//# sourceMappingURL=CommandManager.js.map
