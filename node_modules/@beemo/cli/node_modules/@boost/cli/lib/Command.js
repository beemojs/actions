'use strict';

const _excluded = ["description", "options", "params"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var React = require('react');

var execa = require('execa');

var CLIError = require('./CLIError.js');

var CommandManager = require('./CommandManager.js');

var constants = require('./constants.js');

var Config = require('./decorators/Config.js');

var mapCommandMetadata = require('./helpers/mapCommandMetadata.js');

var getConstructor = require('./metadata/getConstructor.js');

var getInheritedCategories = require('./metadata/getInheritedCategories.js');

var getInheritedOptions = require('./metadata/getInheritedOptions.js');

var globalOptions = require('./metadata/globalOptions.js');

var validateConfig = require('./metadata/validateConfig.js');

var validateOptions = require('./metadata/validateOptions.js');

var validateParams = require('./metadata/validateParams.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var React__default = /*#__PURE__*/_interopDefault(React);

var execa__default = /*#__PURE__*/_interopDefault(execa);
/* eslint-disable max-classes-per-file, @typescript-eslint/consistent-type-assertions */

/**
 * Create a proxy command using itself as the super class.
 */


function createProxyCommand(path, proxyConfig, runner) {
  var _dec, _class;

  const description = proxyConfig.description,
        options = proxyConfig.options,
        params = proxyConfig.params,
        config = _objectWithoutProperties(proxyConfig, _excluded);

  let ProxyCommand = (_dec = Config.Config(path, description, config), _dec(_class = class ProxyCommand extends Command {
    run() {
      return runner.call(this, this[constants.INTERNAL_OPTIONS], this[constants.INTERNAL_PARAMS], this.rest);
    }

  }) || _class);

  if (options !== undefined) {
    ProxyCommand.options = options;
  }

  if (params !== undefined) {
    ProxyCommand.params = params;
  }

  return new ProxyCommand();
}

class Command extends CommandManager.CommandManager {
  // Args

  /** Value of `--help`, `-h` passed on the command line. */

  /** Value of `--locale` passed on the command line. */

  /** Additional arguments passed after `--` on the command line. */

  /** Unknown options passed on the command line. */

  /** Value of `--version`, `-v` passed on the command line. */
  // Methods

  /** Method to exit the current program, with an optional error code. */

  /** Method to log to the console using a log level. */
  // Internals

  /** @internal */

  /** @internal */

  /** @internal */
  constructor(options) {
    super(options);
    this.help = false;
    this.locale = 'en';
    this.rest = [];
    this.unknown = {};
    this.version = false;
    this.exit = void 0;
    this.log = void 0;
    this[constants.INTERNAL_OPTIONS] = void 0;
    this[constants.INTERNAL_PARAMS] = void 0;
    this[constants.INTERNAL_PROGRAM] = void 0;

    this.runProgram = argv => this.getProgram().run(argv, undefined, true);

    this.runTask = (task, ...args) => {
      // We dont want tasks to have full access to the command
      // and its methods, so recreate a similar but smaller context.
      const context = _objectSpread(_objectSpread({
        exit: this.exit,
        log: this.log,
        rest: this.rest,
        unknown: this.unknown
      }, this[constants.INTERNAL_OPTIONS]), {}, {
        runProgram: this.runProgram,
        runTask: this.runTask
      });

      return task.apply(context, args);
    };

    this.handleBeforeRegister = subPath => {
      const path = this.getPath();

      if (!subPath.startsWith(path)) {
        throw new CLIError.CLIError('COMMAND_INVALID_SUBPATH', [subPath, path]);
      }
    };

    const ctor = getConstructor.getConstructor(this);
    validateConfig.validateConfig(this.constructor.name, {
      aliases: ctor.aliases,
      allowUnknownOptions: ctor.allowUnknownOptions,
      allowVariadicParams: ctor.allowVariadicParams,
      categories: ctor.categories,
      category: ctor.category,
      deprecated: ctor.deprecated,
      description: ctor.description,
      hidden: ctor.hidden,
      path: ctor.path,
      usage: ctor.usage
    });
    validateOptions.validateOptions(ctor.options);
    validateParams.validateParams(ctor.params);
    this.onBeforeRegister.listen(this.handleBeforeRegister);
  }
  /**
   * Validate options passed to the constructor.
   */
  // Empty blueprint so that sub-classes may type correctly


  blueprint(predicates) {
    return {};
  }
  /**
   * Create a React element based on the Help component.
   */


  async createHelp() {
    var _this$constants$INTER;

    const metadata = this.getMetadata();

    const _await$Promise$resolv = await Promise.resolve().then(function () {
      return require('./components/Help.js');
    }),
          Help = _await$Promise$resolv.Help;

    return /*#__PURE__*/React__default['default'].createElement(Help, {
      categories: metadata.categories,
      commands: mapCommandMetadata.mapCommandMetadata(metadata.commands),
      config: metadata,
      delimiter: (_this$constants$INTER = this[constants.INTERNAL_PROGRAM]) === null || _this$constants$INTER === void 0 ? void 0 : _this$constants$INTER.options.delimiter,
      header: metadata.path,
      options: metadata.options,
      params: metadata.params
    });
  }
  /**
   * Execute a system native command with the given arguments
   * and pass the results through a promise. This does *not* execute Boost CLI
   * commands, use `runProgram()` instead.
   */


  executeCommand(command, args, options = {})
  /* infer */
  {
    const _this$getProgram = this.getProgram(),
          streams = _this$getProgram.streams;

    return execa__default['default'](command, args, _objectSpread(_objectSpread({}, streams), options));
  }
  /**
   * Return the current command class as an arguments object.
   * Options and params must be parsed first to operate correctly.
   */


  getArguments() {
    var _this$constants$INTER2, _this$constants$INTER3;

    return {
      command: this.getPath().split(':'),
      errors: [],
      options: (_this$constants$INTER2 = this[constants.INTERNAL_OPTIONS]) !== null && _this$constants$INTER2 !== void 0 ? _this$constants$INTER2 : {},
      params: (_this$constants$INTER3 = this[constants.INTERNAL_PARAMS]) !== null && _this$constants$INTER3 !== void 0 ? _this$constants$INTER3 : [],
      rest: this.rest,
      unknown: this.unknown
    };
  }
  /**
   * Validate and return all metadata registered to this command instance.
   */


  getMetadata() {
    const ctor = getConstructor.getConstructor(this);
    const options = {}; // Since default values for options are represented as class properties,
    // we need to inject the defaults into the argument parsing layer.
    // We can easily do this here and avoid a lot of headache.

    Object.entries(getInheritedOptions.getInheritedOptions(this)).forEach(([option, config]) => {
      var _this$option;

      options[option] = _objectSpread(_objectSpread({}, config), {}, {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        default: (_this$option = this[option]) !== null && _this$option !== void 0 ? _this$option : config.default
      });
    });
    return {
      aliases: ctor.aliases,
      allowUnknownOptions: ctor.allowUnknownOptions,
      allowVariadicParams: ctor.allowVariadicParams,
      categories: getInheritedCategories.getInheritedCategories(this),
      category: ctor.category,
      commands: this.commands,
      deprecated: ctor.deprecated,
      description: ctor.description,
      hidden: ctor.hidden,
      options,
      params: ctor.params,
      path: ctor.path,
      usage: ctor.usage
    };
  }
  /**
   * Return metadata as options for argument parsing.
   */


  getParserOptions() {
    const _this$getMetadata = this.getMetadata(),
          aliases = _this$getMetadata.aliases,
          allowUnknownOptions = _this$getMetadata.allowUnknownOptions,
          allowVariadicParams = _this$getMetadata.allowVariadicParams,
          options = _this$getMetadata.options,
          params = _this$getMetadata.params,
          path = _this$getMetadata.path;

    return {
      commands: [path, ...aliases],
      options,
      params,
      unknown: allowUnknownOptions,
      variadic: Boolean(allowVariadicParams)
    };
  }
  /**
   * Return the command path (canonical name on the command line).
   */


  getPath() {
    return getConstructor.getConstructor(this).path;
  }
  /**
   * Render a React element with Ink and output to the configured streams.
   */


  async render(element) {
    return this.getProgram().renderElement(element);
  }
  /**
   * Run the program within itself, by passing a custom command and argv list.
   */

  /**
   * Create a proxy command using itself as the super class.
   */


  createProxyCommand(path, config, runner) {
    return createProxyCommand(path, config, runner);
  }
  /**
   * Return the program instance or fail.
   */


  getProgram() {
    const program = this[constants.INTERNAL_PROGRAM];

    if (!program) {
      throw new CLIError.CLIError('COMMAND_NO_PROGRAM');
    }

    return program;
  }
  /**
   * Verify sub-command is prefixed with the correct path.
   */


}

Command.aliases = [];
Command.allowUnknownOptions = false;
Command.allowVariadicParams = false;
Command.categories = {};
Command.category = '';
Command.description = '';
Command.deprecated = false;
Command.hidden = false;
Command.options = globalOptions.globalOptions;
Command.params = [];
Command.path = '';
Command.usage = '';
exports.Command = Command;
exports.createProxyCommand = createProxyCommand;
//# sourceMappingURL=Command.js.map
