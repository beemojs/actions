import { PrimitiveType } from '@boost/args';
import { Blueprint, Path, Predicates } from '@boost/common';
import { ConcurrentEvent, Event } from '@boost/event';
import { Plugin } from '@boost/plugin';
import { ConfigContext } from './contexts/ConfigContext';
import { DriverContext } from './contexts/DriverContext';
import { Argv, BeemoTool, ConfigObject, Driverable, DriverCommandConfig, DriverCommandRegistration, DriverCommandRunner, DriverMetadata, DriverOptions, DriverOutput, DriverOutputStrategy, Execution } from './types';
export declare abstract class Driver<Config extends object = {}, Options extends DriverOptions = DriverOptions> extends Plugin<BeemoTool, Options> implements Driverable {
    commands: DriverCommandRegistration<any, any>[];
    config: Config;
    metadata: DriverMetadata;
    tool: BeemoTool;
    output: DriverOutput;
    readonly onLoadProviderConfig: Event<[ConfigContext<{}>, Path, Config], string>;
    readonly onLoadConsumerConfig: Event<[ConfigContext<{}>, Config], string>;
    readonly onMergeConfig: Event<[ConfigContext<{}>, Config], string>;
    readonly onCreateConfigFile: Event<[ConfigContext<{}>, Path, Config], string>;
    readonly onCopyConfigFile: Event<[ConfigContext<{}>, Path, Config], string>;
    readonly onReferenceConfigFile: Event<[ConfigContext<{}>, Path, Config], string>;
    readonly onTemplateConfigFile: Event<[ConfigContext<{}>, Path, string | ConfigObject], string>;
    readonly onDeleteConfigFile: Event<[ConfigContext<{}>, Path], string>;
    readonly onBeforeExecute: ConcurrentEvent<[DriverContext<import("./contexts/DriverContext").DriverContextOptions>, Argv], string>;
    readonly onAfterExecute: ConcurrentEvent<[DriverContext<import("./contexts/DriverContext").DriverContextOptions>, unknown], string>;
    readonly onFailedExecute: ConcurrentEvent<[DriverContext<import("./contexts/DriverContext").DriverContextOptions>, Error], string>;
    static validate(driver: Driver): void;
    blueprint({ array, object, string, bool }: Predicates): Blueprint<DriverOptions>;
    bootstrap(): void;
    startup(tool: BeemoTool): void;
    /**
     * Special case for merging arrays.
     */
    doMerge(prevValue: unknown, nextValue: unknown): unknown;
    /**
     * Extract the error message when the driver fails to execute.
     */
    extractErrorMessage(error: {
        message: string;
    }): string;
    /**
     * Format the configuration file before it's written.
     */
    formatConfig(data: Config): string;
    /**
     * Return the module name without the Beemo namespace.
     */
    getName(): string;
    /**
     * Return a list of user defined arguments.
     */
    getArgs(): Argv;
    /**
     * Return a list of dependent drivers.
     */
    getDependencies(): string[];
    /**
     * Either return the tool override strategy, or the per-driver strategy.
     */
    getOutputStrategy(): DriverOutputStrategy;
    /**
     * Return a list of supported CLI options.
     */
    getSupportedOptions(): string[];
    /**
     * Extract the current version of the installed driver via its binary.
     */
    getVersion(): string;
    /**
     * Merge multiple configuration objects.
     */
    mergeConfig(prev: Config, next: Config): Config;
    /**
     * Handle command failures according to this driver.
     */
    processFailure(error: Execution): void;
    /**
     * Handle successful commands according to this driver.
     */
    processSuccess(response: Execution): void;
    /**
     * Register a sub-command within the CLI.
     */
    registerCommand<O extends object, P extends PrimitiveType[]>(path: string, config: DriverCommandConfig<O, P>, runner: DriverCommandRunner<O, P>): this;
    /**
     * Set metadata about the binary/executable in which this driver wraps.
     */
    setMetadata(metadata: Partial<DriverMetadata>): this;
    /**
     * Store the raw output of the driver's execution.
     */
    setOutput(type: keyof DriverOutput, value: string): this;
}
//# sourceMappingURL=Driver.d.ts.map