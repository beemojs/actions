import execa, { Options as ExecaOptions } from 'execa';
import { Arguments, ParserOptions } from '@boost/args';
import { Blueprint, Predicates } from '@boost/common';
import { ConcurrentEvent } from '@boost/event';
import { Plugin } from '@boost/plugin';
import { ScriptContext } from './contexts/ScriptContext';
import { Argv, BeemoTool, Scriptable } from './types';
export declare abstract class Script<O extends object = {}, Options extends object = {}> extends Plugin<BeemoTool, Options> implements Scriptable<O> {
    tool: BeemoTool;
    readonly onBeforeExecute: ConcurrentEvent<[ScriptContext, Argv], string>;
    readonly onAfterExecute: ConcurrentEvent<[ScriptContext, unknown], string>;
    readonly onFailedExecute: ConcurrentEvent<[ScriptContext, Error], string>;
    static validate(script: Script): void;
    blueprint(preds: Predicates): Blueprint<object>;
    bootstrap(): void;
    startup(tool: BeemoTool): void;
    /**
     * Define a configuration object to parse args with.
     */
    parse(): ParserOptions<O>;
    /**
     * Execute a command with the given arguments and pass the results through a promise.
     */
    executeCommand(command: string, args: string[], options?: ExecaOptions): Promise<execa.ExecaReturnValue<string>>;
    /**
     * Execute the script with the context and parsed args.
     */
    abstract execute(context: ScriptContext, args: Arguments<O>): Promise<unknown>;
}
//# sourceMappingURL=Script.d.ts.map