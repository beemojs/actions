import { Blueprint, Contract, PackageStructure, Path, PortablePath, Predicates, Project } from '@boost/common';
import { Debugger } from '@boost/debug';
import { Event } from '@boost/event';
import { Writable } from '@boost/log';
import { Registry } from '@boost/plugin';
import { Translator } from '@boost/translate';
import { Config } from './Config';
import { ConfigContext } from './contexts/ConfigContext';
import { Context } from './contexts/Context';
import { DriverContext } from './contexts/DriverContext';
import { ScaffoldContext } from './contexts/ScaffoldContext';
import { ScriptContext } from './contexts/ScriptContext';
import { Driver } from './Driver';
import { Script } from './Script';
import { Argv, ConfigFile } from './types';
export interface ToolOptions {
    argv: Argv;
    cwd?: PortablePath;
    projectName?: string;
    resourcePaths?: string[];
}
export declare class Tool extends Contract<ToolOptions> {
    config: ConfigFile;
    context?: Context;
    errStream?: Writable;
    outStream?: Writable;
    package: PackageStructure;
    readonly argv: Argv;
    readonly configManager: Config;
    readonly cwd: Path;
    readonly debug: Debugger;
    readonly driverRegistry: Registry<Driver>;
    readonly msg: Translator;
    readonly project: Project;
    readonly onResolveDependencies: Event<[ConfigContext<{}>, Driver<{}, import("./types").DriverOptions>[]], string>;
    readonly onRunCreateConfig: Event<[ConfigContext<{}>, string[]], string>;
    readonly onRunDriver: Event<[DriverContext<import("./contexts/DriverContext").DriverContextOptions>, Driver<{}, import("./types").DriverOptions>], string>;
    readonly onRunScaffold: Event<[ScaffoldContext, string, string, (string | undefined)?], string>;
    readonly onRunScript: Event<[ScriptContext], string>;
    readonly scriptRegistry: Registry<Script>;
    constructor(options: ToolOptions);
    blueprint({ array, instance, string, union }: Predicates): Blueprint<ToolOptions>;
    bootstrap(): Promise<void>;
    /**
     * If the config module has an index that exports a function,
     * execute it with the current tool instance.
     */
    bootstrapConfigModule(): Promise<this>;
    /**
     * Validate the configuration module and return an absolute path to its root folder.
     */
    getConfigModuleRoot(): Path;
    /**
     * Delete config files if a process fails.
     */
    cleanupOnFailure(error?: Error): void;
    /**
     * Create a pipeline to run the create config files flow.
     */
    createConfigurePipeline(args: ConfigContext['args'], driverNames?: string[]): import("@boost/pipeline").SerialPipeline<{}, ConfigContext<{}>, Path[], Path[]>;
    /**
     * Execute all routines for the chosen driver.
     */
    createRunDriverPipeline(args: DriverContext['args'], driverName: string, parallelArgv?: Argv[]): import("@boost/pipeline").SerialPipeline<{}, DriverContext<import("./contexts/DriverContext").DriverContextOptions>, unknown, unknown>;
    /**
     * Run a script found within the configuration module.
     */
    createRunScriptPipeline(args: ScriptContext['args'], scriptName: string): import("@boost/pipeline").SerialPipeline<{}, ScriptContext, unknown, unknown>;
    /**
     * Create a pipeline to run the scaffolding flow.
     */
    createScaffoldPipeline(args: ScaffoldContext['args'], generator: string, action: string, name?: string): import("@boost/pipeline").SerialPipeline<{}, ScaffoldContext, unknown, unknown>;
    /**
     * Resolve modules on *behalf* of the configuration module and within the context
     * of its dependencies. This functionality is necessary to satisfy Yarn PnP and
     * resolving plugins that aren't listed as direct dependencies.
     */
    resolveForPnP(id: string): string;
    /**
     * Prepare the context object by setting default values for specific properties.
     */
    protected prepareContext<T extends Context>(context: T): T;
}
//# sourceMappingURL=Tool.d.ts.map