import execa from 'execa';
import { Blueprint, Predicates } from '@boost/common';
import { AnyWorkUnit, Routine } from '@boost/pipeline';
import { DriverContext } from '../../contexts/DriverContext';
import { OptionMap } from '../../helpers/filterArgs';
import { Argv, Execution, RoutineOptions } from '../../types';
export interface ExecuteCommandOptions extends RoutineOptions {
    additionalArgv?: Argv;
    argv?: Argv;
    forceConfigOption?: boolean;
    packageRoot?: string;
}
export declare class ExecuteCommandRoutine extends Routine<unknown, unknown, ExecuteCommandOptions> {
    blueprint({ array, bool, instance, string }: Predicates): Blueprint<ExecuteCommandOptions>;
    execute(context: DriverContext): Promise<Execution>;
    /**
     * Capture output when output strategy is "stream" or "pipe".
     */
    captureOutput(context: DriverContext, stream: execa.ExecaChildProcess): import("../../types").DriverOutputStrategy | "watch";
    /**
     * When workspaces are enabled, some drivers require the config to be within each workspace,
     * instead of being referenced from the root, so we need to copy it.
     */
    copyConfigToWorkspacePackage(context: DriverContext, argv: Argv): Argv;
    /**
     * Expand arguments that look like globs.
     */
    expandGlobPatterns(context: DriverContext, argv: Argv): Argv;
    /**
     * Extract native supported options and flags from driver help output.
     */
    extractNativeOptions(context: DriverContext): Promise<OptionMap>;
    /**
     * Filter unknown and or unsupported CLI options from the arguments passed to the CLI.
     * Utilize the driver's help option/command to determine accurate options.
     */
    filterUnknownOptions(context: DriverContext, argv: Argv): Promise<Argv>;
    /**
     * Gather arguments from all sources to pass to the driver.
     */
    gatherArgs(context: DriverContext): Argv;
    /**
     * Run some validation on additional/parallel args.
     */
    getAdditionalArgs(): Argv;
    /**
     * Return args from the command line.
     */
    getCommandLineArgs(): Argv;
    /**
     * Return args from the primary driver.
     */
    getDriverArgs(context: DriverContext): Argv;
    /**
     * Include --config option if driver requires it (instead of auto-lookup resolution).
     */
    includeConfigOption(context: DriverContext, prevArgv: Argv): Argv;
    /**
     * Execute the driver's command with the filtered arguments and handle the
     * success and failures with the driver itself.
     */
    runCommandWithArgs(context: DriverContext, argv: Argv, workUnit?: AnyWorkUnit): Promise<Execution>;
}
//# sourceMappingURL=ExecuteCommandRoutine.d.ts.map