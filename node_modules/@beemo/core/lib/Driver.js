'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const execa = require('execa');

const mergeWith = require('lodash/mergeWith');

const common = require('@boost/common');

const event = require('@boost/event');

const plugin = require('@boost/plugin');

const constants = require('./constants.js');

const isClassInstance = require('./helpers/isClassInstance.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

const execa__default = /*#__PURE__*/_interopDefault(execa);

const mergeWith__default = /*#__PURE__*/_interopDefault(mergeWith);

class Driver extends plugin.Plugin {
  constructor(...args) {
    super(...args);
    this.commands = [];
    this.config = void 0;
    this.metadata = void 0;
    this.tool = void 0;
    this.output = {
      stderr: '',
      stdout: ''
    };
    this.onLoadProviderConfig = new event.Event('load-provider-config');
    this.onLoadConsumerConfig = new event.Event('load-consumer-config');
    this.onMergeConfig = new event.Event('merge-config');
    this.onCreateConfigFile = new event.Event('create-config-file');
    this.onCopyConfigFile = new event.Event('copy-config-file');
    this.onReferenceConfigFile = new event.Event('reference-config-file');
    this.onTemplateConfigFile = new event.Event('template-config-file');
    this.onDeleteConfigFile = new event.Event('delete-config-file');
    this.onBeforeExecute = new event.ConcurrentEvent('before-execute');
    this.onAfterExecute = new event.ConcurrentEvent('after-execute');
    this.onFailedExecute = new event.ConcurrentEvent('failed-execute');
  }

  static validate(driver) {
    const name = isClassInstance.isClassInstance(driver) && driver.constructor.name || 'Driver';

    if (!common.isObject(driver.options)) {
      throw new Error(`\`${name}\` requires an options object.`);
    }
  }

  blueprint({
    array,
    object,
    string,
    bool
  }) {
    return {
      args: array(string()),
      configStrategy: string(constants.STRATEGY_NATIVE).oneOf([constants.STRATEGY_NATIVE, constants.STRATEGY_CREATE, constants.STRATEGY_REFERENCE, constants.STRATEGY_TEMPLATE, constants.STRATEGY_COPY, constants.STRATEGY_NONE]),
      dependencies: array(string()),
      env: object(string()),
      expandGlobs: bool(true),
      outputStrategy: string(constants.STRATEGY_BUFFER).oneOf([constants.STRATEGY_BUFFER, constants.STRATEGY_PIPE, constants.STRATEGY_STREAM, constants.STRATEGY_NONE]),
      template: string()
    };
  }

  bootstrap() {}

  startup(tool) {
    this.tool = tool;
    this.bootstrap();
  }
  /**
   * Special case for merging arrays.
   */


  doMerge(prevValue, nextValue) {
    if (Array.isArray(prevValue) && Array.isArray(nextValue)) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      return [...new Set([...prevValue, ...nextValue])];
    }

    return undefined;
  }
  /**
   * Extract the error message when the driver fails to execute.
   */


  extractErrorMessage(error) {
    return error.message.split('\n', 1)[0] || '';
  }
  /**
   * Format the configuration file before it's written.
   */


  formatConfig(data) {
    const content = JSON.stringify(data, null, 2);

    if (this.metadata.configName.endsWith('.js')) {
      return `module.exports = ${content};`;
    }

    return content;
  }
  /**
   * Return the module name without the Beemo namespace.
   */


  getName() {
    return this.name.split('-').pop();
  }
  /**
   * Return a list of user defined arguments.
   */


  getArgs() {
    return common.toArray(this.options.args);
  }
  /**
   * Return a list of dependent drivers.
   */


  getDependencies() {
    return [// Always required; configured by the driver
    ...this.metadata.dependencies, // Custom; configured by the consumer
    ...common.toArray(this.options.dependencies)];
  }
  /**
   * Either return the tool override strategy, or the per-driver strategy.
   */


  getOutputStrategy() {
    var _ref;

    return (_ref = this.tool.config.execute.output || this.options.outputStrategy) !== null && _ref !== void 0 ? _ref : constants.STRATEGY_BUFFER;
  }
  /**
   * Return a list of supported CLI options.
   */


  getSupportedOptions() {
    return [];
  }
  /**
   * Extract the current version of the installed driver via its binary.
   */


  getVersion() {
    var _execa__default$defau;

    const _this$metadata = this.metadata,
          bin = _this$metadata.bin,
          versionOption = _this$metadata.versionOption;
    const version = (((_execa__default$defau = execa__default["default"].sync(bin, [versionOption], {
      preferLocal: true
    })) === null || _execa__default$defau === void 0 ? void 0 : _execa__default$defau.stdout) || '').trim();
    const match = version.match(/(\d+)\.(\d+)\.(\d+)/u);
    return match ? match[0] : '0.0.0';
  }
  /**
   * Merge multiple configuration objects.
   */


  mergeConfig(prev, next) {
    return mergeWith__default["default"](prev, next, this.doMerge);
  }
  /**
   * Handle command failures according to this driver.
   */


  processFailure(error) {
    const _error$stderr = error.stderr,
          stderr = _error$stderr === void 0 ? '' : _error$stderr,
          _error$stdout = error.stdout,
          stdout = _error$stdout === void 0 ? '' : _error$stdout;
    const out = (stderr || stdout).trim();

    if (out) {
      this.setOutput('stderr', out);
    }
  }
  /**
   * Handle successful commands according to this driver.
   */


  processSuccess(response) {
    const _response$stderr = response.stderr,
          stderr = _response$stderr === void 0 ? '' : _response$stderr,
          _response$stdout = response.stdout,
          stdout = _response$stdout === void 0 ? '' : _response$stdout;
    this.setOutput('stderr', stderr.trim());
    this.setOutput('stdout', stdout.trim());
  }
  /**
   * Register a sub-command within the CLI.
   */


  registerCommand(path, config, runner) {
    this.commands.push({
      config,
      path,
      runner
    });
    return this;
  }
  /**
   * Set metadata about the binary/executable in which this driver wraps.
   */


  setMetadata(metadata) {
    const _common$predicates = common.predicates,
          array = _common$predicates.array,
          bool = _common$predicates.bool,
          string = _common$predicates.string,
          object = _common$predicates.object,
          shape = _common$predicates.shape;
    this.metadata = common.optimal(metadata, {
      bin: string().match(/^[a-z]{1}[a-zA-Z0-9-]+$/u).required(),
      commandOptions: object(shape({
        description: string().required(),
        type: string().oneOf(['string', 'number', 'boolean'])
      })),
      configName: string().required(),
      configOption: string('--config'),
      configStrategy: string(constants.STRATEGY_CREATE).oneOf([constants.STRATEGY_CREATE, constants.STRATEGY_REFERENCE, constants.STRATEGY_COPY]),
      dependencies: array(string()),
      description: string(),
      filterOptions: bool(true),
      helpOption: string('--help'),
      title: string().required(),
      useConfigOption: bool(),
      versionOption: string('--version'),
      watchOptions: array(string()),
      workspaceStrategy: string(constants.STRATEGY_REFERENCE).oneOf([constants.STRATEGY_REFERENCE, constants.STRATEGY_COPY])
    }, {
      name: this.constructor.name
    });
    return this;
  }
  /**
   * Store the raw output of the driver's execution.
   */


  setOutput(type, value) {
    this.output[type] = value.trim();
    return this;
  }

}

exports.Driver = Driver;
//# sourceMappingURL=Driver.js.map
