'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');

const module$2 = require('module');

const fs = require('fs-extra');

const common = require('@boost/common');

const debug = require('@boost/debug');

const event = require('@boost/event');

const internal = require('@boost/internal');

const module$1 = require('@boost/module');

const pipeline = require('@boost/pipeline');

const plugin = require('@boost/plugin');

const translate = require('@boost/translate');

const Config = require('./Config.js');

const constants = require('./constants.js');

const ConfigContext = require('./contexts/ConfigContext.js');

const DriverContext = require('./contexts/DriverContext.js');

const ScaffoldContext = require('./contexts/ScaffoldContext.js');

const ScriptContext = require('./contexts/ScriptContext.js');

const Driver = require('./Driver.js');

const CleanupConfigsRoutine = require('./routines/CleanupConfigsRoutine.js');

const ResolveConfigsRoutine = require('./routines/ResolveConfigsRoutine.js');

const RunDriverRoutine = require('./routines/RunDriverRoutine.js');

const RunScriptRoutine = require('./routines/RunScriptRoutine.js');

const ScaffoldRoutine = require('./routines/ScaffoldRoutine.js');

const Script = require('./Script.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

const fs__default = /*#__PURE__*/_interopDefault(fs);

var _dec, _dec2, _dec3, _class;

let Tool = (_dec = common.Memoize(), _dec2 = common.Bind(), _dec3 = common.Bind(), (_class = class Tool extends common.Contract {
  constructor(options) {
    super(options);
    this.config = void 0;
    this.context = void 0;
    this.errStream = void 0;
    this.outStream = void 0;
    this.package = void 0;
    this.argv = void 0;
    this.configManager = void 0;
    this.cwd = void 0;
    this.debug = void 0;
    this.driverRegistry = void 0;
    this.msg = void 0;
    this.project = void 0;
    this.onResolveDependencies = new event.Event('resolve-dependencies');
    this.onRunCreateConfig = new event.Event('run-create-config');
    this.onRunDriver = new event.Event('run-driver');
    this.onRunScaffold = new event.Event('run-scaffold');
    this.onRunScript = new event.Event('run-script');
    this.scriptRegistry = void 0;
    this.argv = this.options.argv;
    this.cwd = common.Path.create(this.options.cwd);
    this.debug = debug.createDebugger('core');
    this.debug('Using beemo v%s', require('../package.json').version);
    this.msg = translate.createTranslator(['app', 'common', 'errors'], [new common.Path(__dirname, '../resources'), ...this.options.resourcePaths]);
    this.driverRegistry = new plugin.Registry('beemo', 'driver', {
      resolver: this.resolveForPnP,
      validate: Driver.Driver.validate
    });
    this.scriptRegistry = new plugin.Registry('beemo', 'script', {
      resolver: this.resolveForPnP,
      validate: Script.Script.validate
    });
    this.project = new common.Project(this.cwd);
    this.configManager = new Config.Config(this.options.projectName, this.resolveForPnP);
  }

  blueprint({
    array,
    instance,
    string,
    union
  }) {
    return {
      argv: array(string()),
      cwd: union([instance(common.Path).notNullable(), string().notEmpty()], process.cwd()),
      projectName: string('beemo').camelCase().notEmpty(),
      resourcePaths: array(string().notEmpty())
    };
  }

  async bootstrap() {
    // Load config
    const _await$this$configMan = await this.configManager.loadConfigFromRoot(this.cwd),
          config = _await$this$configMan.config;

    this.config = config;
    this.package = this.project.getPackage(); // Load drivers

    await this.driverRegistry.loadMany(config.drivers, {
      tool: this
    }); // Load scripts

    await this.scriptRegistry.loadMany(config.scripts, {
      tool: this
    });
  }
  /**
   * If the config module has an index that exports a function,
   * execute it with the current tool instance.
   */


  async bootstrapConfigModule() {
    var _bootstrapModule$boot, _bootstrapModule, _bootstrapModule2;

    this.debug('Bootstrapping configuration module');
    const module = this.config.module;
    let bootstrapModule = null;

    try {
      const root = this.getConfigModuleRoot();
      const resolver = new common.PathResolver().lookupFilePath('index.ts', root).lookupFilePath('index.js', root).lookupFilePath('src/index.ts', root).lookupFilePath('lib/index.js', root);

      if (module !== '@local') {
        resolver.lookupNodeModule(module);
      }

      const _resolver$resolve = resolver.resolve(),
            resolvedPath = _resolver$resolve.resolvedPath;

      bootstrapModule = module$1.requireModule(resolvedPath);
    } catch {
      this.debug('No bootstrap file detected, aborting bootstrap');
      return this;
    }

    const bootstrap = (_bootstrapModule$boot = (_bootstrapModule = bootstrapModule) === null || _bootstrapModule === void 0 ? void 0 : _bootstrapModule.bootstrap) !== null && _bootstrapModule$boot !== void 0 ? _bootstrapModule$boot : (_bootstrapModule2 = bootstrapModule) === null || _bootstrapModule2 === void 0 ? void 0 : _bootstrapModule2.default;
    const isFunction = typeof bootstrap === 'function';
    this.debug.invariant(isFunction, 'Executing bootstrap function', 'Found', 'Not found');

    if (bootstrap && isFunction) {
      await bootstrap(this);
    }

    return this;
  }
  /**
   * Validate the configuration module and return an absolute path to its root folder.
   */


  getConfigModuleRoot() {
    const module = this.config.module;
    this.debug('Locating configuration module root');

    if (!module) {
      throw new Error(this.msg('errors:moduleConfigMissing'));
    } // Allow for local development


    if (module === '@local') {
      this.debug('Using %s configuration module', internal.color.moduleName('@local'));
      return new common.Path(this.options.cwd);
    } // Reference a node module


    let rootPath;

    try {
      rootPath = common.Path.resolve(this.resolveForPnP(`${module}/package.json`)).parent();
    } catch {
      throw new Error(this.msg('errors:moduleMissing', {
        module
      }));
    }

    this.debug('Found configuration module root at path: %s', internal.color.filePath(rootPath));
    return rootPath;
  }
  /**
   * Delete config files if a process fails.
   */


  cleanupOnFailure(error) {
    const context = this.context;

    if (!error || !context) {
      return;
    } // Must not be async!


    if (Array.isArray(context.configPaths)) {
      context.configPaths.forEach(config => {
        fs__default["default"].removeSync(config.path.path());
      });
    }
  }
  /**
   * Create a pipeline to run the create config files flow.
   */


  createConfigurePipeline(args, driverNames = []) {
    const context = this.prepareContext(new ConfigContext.ConfigContext(args)); // Create for all enabled drivers

    if (driverNames.length === 0) {
      this.driverRegistry.getAll().forEach(driver => {
        context.addDriverDependency(driver);
        driverNames.push(driver.getName());
      });
      this.debug('Running with all drivers'); // Create for one or many driver
    } else {
      driverNames.forEach(driverName => {
        context.addDriverDependency(this.driverRegistry.get(driverName));
      });
      this.debug('Running with %s driver(s)', driverNames.join(', '));
    }

    this.onRunCreateConfig.emit([context, driverNames]);
    return new pipeline.WaterfallPipeline(context).pipe(new ResolveConfigsRoutine.ResolveConfigsRoutine('config', this.msg('app:configGenerate'), {
      tool: this
    }));
  }
  /**
   * Execute all routines for the chosen driver.
   */


  createRunDriverPipeline(args, driverName, parallelArgv = []) {
    const driver = this.driverRegistry.get(driverName);
    const context = this.prepareContext(new DriverContext.DriverContext(args, driver, parallelArgv));
    const version = driver.getVersion();
    this.onRunDriver.emit([context, driver], driverName);
    this.debug('Running with %s v%s driver', driverName, version);
    return new pipeline.WaterfallPipeline(context, driverName).pipe(new ResolveConfigsRoutine.ResolveConfigsRoutine('config', this.msg('app:configGenerate'), {
      tool: this
    })).pipe(new RunDriverRoutine.RunDriverRoutine('driver', this.msg('app:driverRun', {
      name: driver.metadata.title,
      version
    }), {
      tool: this
    })).pipe(new CleanupConfigsRoutine.CleanupConfigsRoutine('cleanup', this.msg('app:cleanup'), {
      tool: this
    }) // Only add cleanup routine if we need it
    .skip(!this.config.configure.cleanup));
  }
  /**
   * Run a script found within the configuration module.
   */


  createRunScriptPipeline(args, scriptName) {
    if (!scriptName || !scriptName.match(constants.KEBAB_PATTERN)) {
      throw new Error(this.msg('errors:scriptNameInvalidFormat'));
    }

    const context = this.prepareContext(new ScriptContext.ScriptContext(args, scriptName));
    this.onRunScript.emit([context], scriptName);
    this.debug('Running with %s script', context.scriptName);
    return new pipeline.WaterfallPipeline(context).pipe(new RunScriptRoutine.RunScriptRoutine('script', this.msg('app:scriptRun', {
      name: scriptName
    }), {
      tool: this
    }));
  }
  /**
   * Create a pipeline to run the scaffolding flow.
   */


  createScaffoldPipeline(args, generator, action, name = '') {
    const context = this.prepareContext(new ScaffoldContext.ScaffoldContext(args, generator, action, name));
    this.onRunScaffold.emit([context, generator, action, name]);
    this.debug('Creating scaffold pipeline');
    return new pipeline.WaterfallPipeline(context).pipe(new ScaffoldRoutine.ScaffoldRoutine('scaffold', this.msg('app:scaffoldGenerate'), {
      tool: this
    }));
  }
  /**
   * Resolve modules on *behalf* of the configuration module and within the context
   * of its dependencies. This functionality is necessary to satisfy Yarn PnP and
   * resolving plugins that aren't listed as direct dependencies.
   */


  resolveForPnP(id) {
    // Create a `require` on behalf of the project root
    const rootRequire = module$2.createRequire(this.cwd.append('package.json').path()); // Attempt to resolve from the root incase dependencies have been defined there

    try {
      return rootRequire.resolve(id);
    } catch {// Ignore
    } // Otherwise, create a `require` on behalf of the configuration module,
    // which is ALSO resolved from the root (assumes the config module is a dependency there)


    const moduleRequire = module$2.createRequire(rootRequire.resolve(`${this.config.module}/package.json`));
    return moduleRequire.resolve(id);
  }
  /**
   * Prepare the context object by setting default values for specific properties.
   */


  prepareContext(context) {
    context.argv = this.argv;
    context.cwd = this.cwd;
    context.configModuleRoot = this.getConfigModuleRoot();
    context.workspaceRoot = this.project.root;
    context.workspaces = this.project.getWorkspaceGlobs(); // Make the tool available for all processes

    const processObject = {
      context,
      tool: this
    };
    Object.defineProperties(process, {
      beemo: {
        configurable: true,
        enumerable: true,
        value: processObject
      },
      [this.options.projectName]: {
        configurable: true,
        enumerable: true,
        value: processObject
      }
    }); // Set the current class to the tool instance

    this.context = context;
    return context;
  }

}, (_rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "getConfigModuleRoot", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "getConfigModuleRoot"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "cleanupOnFailure", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "cleanupOnFailure"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "resolveForPnP", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "resolveForPnP"), _class.prototype)), _class));
exports.Tool = Tool;
//# sourceMappingURL=Tool.js.map
