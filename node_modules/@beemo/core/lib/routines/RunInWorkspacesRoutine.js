'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const common = require('@boost/common');

const pipeline = require('@boost/pipeline');

const terminal = require('@boost/terminal');

const isPatternMatch = require('../helpers/isPatternMatch.js');

const MAX_ERROR_LINES = 5;

class RunInWorkspacesRoutine extends pipeline.Routine {
  constructor(...args) {
    super(...args);
    this.routines = [];
    this.workspacePackages = [];
  }

  blueprint({
    instance
  }) {
    return {
      tool: instance().required().notNullable()
    };
  }

  async execute(context) {
    const args = context.args,
          workspaces = context.workspaces;
    const tool = this.options.tool; // Determine packages to run plugins in

    if (args.options.workspaces) {
      if (!workspaces || workspaces.length === 0) {
        throw new Error(tool.msg('errors:workspacesNotEnabled', {
          arg: args.options.workspaces
        }));
      }

      this.workspacePackages = tool.project.getWorkspacePackages();
      this.getFilteredWorkspacePackages(context).forEach(pkg => {
        this.pipeRoutine(context, pkg.metadata.packageName, pkg.metadata.packagePath);
      });
    } else {
      this.pipeRoutine(context);
    }

    const value = await this.getInitialValue(context);
    const batches = this.orderByWorkspacePriorityGraph(context);
    const allErrors = [];
    const allResults = [];
    const concurrency = context.args.options.concurrency || tool.config.execute.concurrency || undefined;

    for (const batch of batches) {
      const pipeline = batch.reduce((pl, routine) => pl.add(routine), this.createPooledPipeline(context, value, {
        concurrency
      })); // eslint-disable-next-line no-await-in-loop

      const _await$pipeline$run = await pipeline.run(),
            errors = _await$pipeline$run.errors,
            results = _await$pipeline$run.results;

      allResults.push(...results);

      if (errors.length > 0) {
        allErrors.push(...errors);
      }
    }

    if (allErrors.length > 0) {
      this.formatAndThrowErrors(allErrors);
    } // Not running in workspaces, so return value directly


    return context.args.options.workspaces ? allResults : allResults[0];
  }
  /**
   * When a list of errors are available, concatenate them and throw a new error.
   */


  formatAndThrowErrors(errors) {
    let message = this.options.tool.msg('errors:executeFailed');
    errors.forEach(error => {
      let content = terminal.stripAnsi(error.stderr || error.stdout || '').trim().split('\n'); // istanbul ignore next

      if (content.length >= MAX_ERROR_LINES) {
        const count = content.length - MAX_ERROR_LINES;
        content = content.slice(0, MAX_ERROR_LINES);

        if (count > 0) {
          content.push(this.options.tool.msg('errors:executeFailedMoreLines', {
            count
          }));
        }
      }

      message += '\n\n';
      message += terminal.style.reset.yellow(error.message);

      if (content.length > 0) {
        message += '\n';
        message += terminal.style.reset.gray(content.join('\n'));
      }
    });
    message += '\n';
    const error = new Error(message.trim()); // Inherit stack for easier debugging.

    if (errors.length === 1) {
      error.stack = String(errors[0].stack).split('\n').slice(1).join('\n');
    }

    throw error;
  }
  /**
   * Return a list of workspaces optionally filtered.
   */


  getFilteredWorkspacePackages(context) {
    return this.workspacePackages.filter(pkg => isPatternMatch.isPatternMatch(pkg.package.name, context.args.options.workspaces));
  }
  /**
   * Return the initial value for the pipeline.
   */


  getInitialValue(context) {
    return null;
  }
  /**
   * Group routines in order of which they are dependend on.
   */


  orderByWorkspacePriorityGraph(context) {
    const enabled = context.args.options.graph || this.options.tool.config.execute.graph || false;

    if (!enabled || !context.args.options.workspaces) {
      return [this.routines];
    } // Create lookups


    const packages = []; // Without metadata

    const metadata = {}; // By package name

    this.workspacePackages.forEach(wsp => {
      packages.push(wsp.package);
      metadata[wsp.package.name] = wsp.metadata;
    }); // Batch based on packages

    const batchList = new common.PackageGraph(packages).resolveBatchList();
    const batches = [];
    batchList.forEach(batch => {
      const routines = batch.map(pkg => this.routines.find(route => route.key === metadata[pkg.name].packageName)).filter(Boolean);

      if (routines.length > 0) {
        batches.push(routines);
      }
    });
    return batches;
  }
  /**
   * Pipe a routine for the entire project or a workspace package at the defined path.
   */


}

exports.RunInWorkspacesRoutine = RunInWorkspacesRoutine;
//# sourceMappingURL=RunInWorkspacesRoutine.js.map
