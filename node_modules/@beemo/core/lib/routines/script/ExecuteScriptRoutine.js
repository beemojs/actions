'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const args = require('@boost/args');

const common = require('@boost/common');

const pipeline = require('@boost/pipeline');

const formatExecReturn = require('../../helpers/formatExecReturn.js');

class ExecuteScriptRoutine extends pipeline.Routine {
  blueprint({
    instance,
    string
  }) {
    return {
      packageRoot: string(),
      tool: instance().required().notNullable()
    };
  }
  /**
   * Run the script while also parsing arguments to use as options.
   *
   * When a script is ran in multiple workspace packages, each context should have a different root,
   * but we can't modify the context without changing the reference across all packages.
   * So create a new context, copy over the old properties, and set the new root.
   */


  async execute(oldContext, script) {
    const context = oldContext.clone(); // Update the cwd to point to the package root

    if (this.options.packageRoot) {
      context.cwd = new common.Path(this.options.packageRoot);
    }

    const argv = context.argv;
    this.debug('Executing script with args "%s"', argv.join(' '));
    await script.onBeforeExecute.emit([context, argv]);
    const args$1 = args.parse(argv, script.parse());
    let result;

    try {
      result = await script.execute(context, args$1);
      this.debug('  Success: %o', formatExecReturn.formatExecReturn(result));
      await script.onAfterExecute.emit([context, result]);
    } catch (error) {
      if (common.instanceOf(error, Error)) {
        this.debug('  Failure: %o', formatExecReturn.formatExecReturn(error));
        this.debug('  Error message: %s', error.message);
        await script.onFailedExecute.emit([context, error]);
      }

      throw error;
    }

    return result;
  }

}

exports.ExecuteScriptRoutine = ExecuteScriptRoutine;
//# sourceMappingURL=ExecuteScriptRoutine.js.map
