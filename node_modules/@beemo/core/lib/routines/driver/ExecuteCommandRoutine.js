'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.js');

const glob = require('fast-glob');

const fs = require('fs-extra');

const isGlob = require('is-glob');

const merge = require('lodash/merge');

const args = require('@boost/args');

const common = require('@boost/common');

const internal = require('@boost/internal');

const pipeline = require('@boost/pipeline');

const constants = require('../../constants.js');

const filterArgs = require('../../helpers/filterArgs.js');

const formatExecReturn = require('../../helpers/formatExecReturn.js');

const BatchStream = require('../../streams/BatchStream.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

const glob__default = /*#__PURE__*/_interopDefault(glob);

const fs__default = /*#__PURE__*/_interopDefault(fs);

const isGlob__default = /*#__PURE__*/_interopDefault(isGlob);

const merge__default = /*#__PURE__*/_interopDefault(merge);

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class;

const OPTION_PATTERN = /-?-[a-z0-9-]+(,|\s)/giu;
let ExecuteCommandRoutine = (_dec = common.Bind(), _dec2 = common.Bind(), _dec3 = common.Bind(), _dec4 = common.Bind(), _dec5 = common.Bind(), _dec6 = common.Bind(), _dec7 = common.Bind(), (_class = class ExecuteCommandRoutine extends pipeline.Routine {
  blueprint({
    array,
    bool,
    instance,
    string
  }) {
    return {
      additionalArgv: array(string()),
      argv: array(string()),
      forceConfigOption: bool(),
      packageRoot: string(),
      tool: instance().required().notNullable()
    };
  }

  async execute(context) {
    const tool = this.options.tool;
    const _this$options = this.options,
          forceConfigOption = _this$options.forceConfigOption,
          packageRoot = _this$options.packageRoot;
    const _context$primaryDrive = context.primaryDriver,
          metadata = _context$primaryDrive.metadata,
          options = _context$primaryDrive.options;
    let pipeline = this.createWaterfallPipeline(context).pipe(tool.msg('app:driverExecuteGatherArgs'), this.gatherArgs);

    if (options.expandGlobs) {
      pipeline = pipeline.pipe(tool.msg('app:driverExecuteExpandGlob'), this.expandGlobPatterns);
    }

    if (metadata.filterOptions) {
      pipeline = pipeline.pipe(tool.msg('app:driverExecuteFilterOptions'), this.filterUnknownOptions);
    }

    if (packageRoot && metadata.workspaceStrategy === constants.STRATEGY_COPY) {
      pipeline = pipeline.pipe(tool.msg('app:driverExecuteCopyWorkspaceConfig'), this.copyConfigToWorkspacePackage);
    } else if (metadata.useConfigOption || forceConfigOption) {
      pipeline = pipeline.pipe(tool.msg('app:driverExecuteIncludeConfigOption'), this.includeConfigOption);
    }

    return pipeline.pipe(tool.msg('app:driverExecute', {
      bin: metadata.bin
    }), this.runCommandWithArgs).run();
  }
  /**
   * Capture output when output strategy is "stream" or "pipe".
   */


  captureOutput(context, stream) {
    const tool = this.options.tool;
    const args = context.args,
          primaryDriver = context.primaryDriver;
    const watchOptions = primaryDriver.metadata.watchOptions;
    const isWatching = watchOptions.some(option => {
      // Option
      if (option.startsWith('-')) {
        return !!context.getRiskyOption(option.replace(/^-{1,2}/u, ''));
      } // Param


      return args.params.includes(option);
    });

    const outHandler = chunk => {
      var _tool$outStream;

      (_tool$outStream = tool.outStream) === null || _tool$outStream === void 0 ? void 0 : _tool$outStream.write(String(chunk));
    };

    const errHandler = chunk => {
      var _tool$errStream;

      (_tool$errStream = tool.errStream) === null || _tool$errStream === void 0 ? void 0 : _tool$errStream.write(String(chunk));
    };

    if (isWatching) {
      const wait = 1000;
      stream.stdout.pipe(new BatchStream.BatchStream({
        wait
      })).on('data', outHandler);
      stream.stderr.pipe(new BatchStream.BatchStream({
        wait
      })).on('data', errHandler);
      return 'watch';
    }

    const strategy = primaryDriver.getOutputStrategy();

    if (strategy === 'stream' || strategy === 'pipe') {
      stream.stdout.on('data', outHandler);
      stream.stderr.on('data', errHandler);
    }

    return strategy;
  }
  /**
   * When workspaces are enabled, some drivers require the config to be within each workspace,
   * instead of being referenced from the root, so we need to copy it.
   */


  copyConfigToWorkspacePackage(context, argv) {
    const packageRoot = this.options.packageRoot;
    this.debug('Copying config files to workspace');
    context.configPaths.forEach(config => {
      fs__default["default"].copyFileSync(config.path.path(), new common.Path(packageRoot, config.path.name()).path());
    });
    return argv;
  }
  /**
   * Expand arguments that look like globs.
   */


  expandGlobPatterns(context, argv) {
    const nextArgv = [];
    this.debug('Expanding glob patterns');
    argv.forEach(arg => {
      if (!arg.startsWith('-') && isGlob__default["default"](arg)) {
        const paths = glob__default["default"].sync(arg, {
          cwd: String(context.cwd),
          onlyDirectories: false,
          onlyFiles: false
        }).map(path => new common.Path(path).path());
        this.debug('  %s %s %s', arg, internal.color.mute('->'), paths.length > 0 ? paths.join(', ') : internal.color.mute(this.options.tool.msg('app:noMatch')));
        nextArgv.push(...paths);
      } else {
        nextArgv.push(arg);
      }
    });
    return nextArgv;
  }
  /**
   * Extract native supported options and flags from driver help output.
   */


  async extractNativeOptions(context) {
    var _stdout$match;

    const driver = context.primaryDriver;
    const env = driver.options.env;
    const options = driver.getSupportedOptions();

    if (options.length > 0) {
      this.debug('Using supported options from driver');
      const nativeOptions = {};
      options.forEach(option => {
        nativeOptions[option] = true;
      });
      return Promise.resolve(nativeOptions);
    }

    this.debug('Extracting native options from help output');

    const _await$this$executeCo = await this.executeCommand(driver.metadata.bin, driver.metadata.helpOption.split(' '), {
      env,
      preferLocal: true
    }),
          stdout = _await$this$executeCo.stdout;

    const nativeOptions = {};
    const matches = (_stdout$match = stdout.match(OPTION_PATTERN)) !== null && _stdout$match !== void 0 ? _stdout$match : [];
    matches.forEach(option => {
      // Trim trailing comma or space
      nativeOptions[option.slice(0, -1)] = true;
    });
    return nativeOptions;
  }
  /**
   * Filter unknown and or unsupported CLI options from the arguments passed to the CLI.
   * Utilize the driver's help option/command to determine accurate options.
   */


  async filterUnknownOptions(context, argv) {
    this.debug('Filtering unknown command line options');
    const nativeOptions = await this.extractNativeOptions(context);

    const _filterArgs$filterArg = filterArgs.filterArgs(argv, {
      allow: nativeOptions
    }),
          filteredArgv = _filterArgs$filterArg.filteredArgv,
          unknownArgv = _filterArgs$filterArg.unknownArgv;

    if (unknownArgv.length > 0) {
      this.debug('Filtered args: %s', internal.color.mute(unknownArgv.join(', ')));
    }

    return filteredArgv;
  }
  /**
   * Gather arguments from all sources to pass to the driver.
   */


  gatherArgs(context) {
    this.debug('Gathering arguments to pass to driver');
    const argv = [// Passed by the driver
    ...this.getDriverArgs(context), // Passed on the command line
    ...this.getCommandLineArgs(), // Passed with parallel "//" operator
    ...this.getAdditionalArgs()]; // Since we combine multiple args, we need to rebuild this.
    // And we need to set this before we filter them.
    // And we need to be sure not to remove existing args.

    context.args = merge__default["default"]({}, args.parse(argv, {
      loose: true,
      options: {}
    }), context.args);
    return argv;
  }
  /**
   * Run some validation on additional/parallel args.
   */


  getAdditionalArgs() {
    const argv = this.options.additionalArgv;
    this.debug.invariant(argv.length > 0, 'From parallel operator', argv.join(' '), 'No arguments');
    return argv;
  }
  /**
   * Return args from the command line.
   */


  getCommandLineArgs() {
    const argv = this.options.argv;
    this.debug.invariant(argv.length > 0, 'From the command line', argv.join(' '), 'No arguments');
    return argv;
  }
  /**
   * Return args from the primary driver.
   */


  getDriverArgs(context) {
    const argv = context.primaryDriver.getArgs();
    this.debug.invariant(argv.length > 0, 'From driver "args" option', argv.join(' '), 'No arguments');
    return argv;
  }
  /**
   * Include --config option if driver requires it (instead of auto-lookup resolution).
   */


  includeConfigOption(context, prevArgv) {
    const primaryDriver = context.primaryDriver;
    const configPath = context.findConfigByName(primaryDriver.metadata.configName);
    const argv = [...prevArgv];

    if (configPath && primaryDriver.metadata.configOption) {
      argv.push(primaryDriver.metadata.configOption, configPath.path.path());
    }

    this.debug('Including config option to args');
    return argv;
  }
  /**
   * Execute the driver's command with the filtered arguments and handle the
   * success and failures with the driver itself.
   */


  async runCommandWithArgs(context, argv, workUnit) {
    const driver = context.primaryDriver;
    const cwd = String(this.options.packageRoot || context.cwd);
    this.debug('Executing command "%s %s" in %s', internal.color.symbol(driver.metadata.bin), argv.join(' '), internal.color.filePath(cwd));
    await driver.onBeforeExecute.emit([context, argv]);

    try {
      const result = await this.executeCommand(driver.metadata.bin, argv, {
        cwd,
        env: driver.options.env,
        preferLocal: true,
        workUnit,
        wrap: stream => this.captureOutput(context, stream)
      });
      this.debug('  Success: %o', formatExecReturn.formatExecReturn(result));
      driver.processSuccess(result);
      await driver.onAfterExecute.emit([context, result]);
      return result;
    } catch (error) {
      const result = error;
      this.debug('  Failure: %o', formatExecReturn.formatExecReturn(result));
      this.debug('  Error message: %s', internal.color.fail(result.message));

      if (result.name !== 'MaxBufferError') {
        driver.processFailure(result);
      }

      await driver.onFailedExecute.emit([context, result]); // https://nodejs.org/api/child_process.html#child_process_event_exit

      throw result.exitCode === null && result.signal === 'SIGKILL' ? new common.ExitError('Out of memory!', 1) : new common.ExitError((driver.extractErrorMessage(result) || '').trim(), result.exitCode);
    }
  }

}, (_rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "captureOutput", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "captureOutput"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "copyConfigToWorkspacePackage", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "copyConfigToWorkspacePackage"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "expandGlobPatterns", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "expandGlobPatterns"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "filterUnknownOptions", [_dec4], Object.getOwnPropertyDescriptor(_class.prototype, "filterUnknownOptions"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "gatherArgs", [_dec5], Object.getOwnPropertyDescriptor(_class.prototype, "gatherArgs"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "includeConfigOption", [_dec6], Object.getOwnPropertyDescriptor(_class.prototype, "includeConfigOption"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "runCommandWithArgs", [_dec7], Object.getOwnPropertyDescriptor(_class.prototype, "runCommandWithArgs"), _class.prototype)), _class));
exports.ExecuteCommandRoutine = ExecuteCommandRoutine;
//# sourceMappingURL=ExecuteCommandRoutine.js.map
