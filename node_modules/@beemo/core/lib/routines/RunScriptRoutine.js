'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');

const camelCase = require('lodash/camelCase');

const upperFirst = require('lodash/upperFirst');

const common = require('@boost/common');

const constants = require('../constants.js');

const filterArgs = require('../helpers/filterArgs.js');

const RunInWorkspacesRoutine = require('./RunInWorkspacesRoutine.js');

const ExecuteScriptRoutine = require('./script/ExecuteScriptRoutine.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

const camelCase__default = /*#__PURE__*/_interopDefault(camelCase);

const upperFirst__default = /*#__PURE__*/_interopDefault(upperFirst);

var _dec, _dec2, _dec3, _class;

let RunScriptRoutine = (_dec = common.Bind(), _dec2 = common.Bind(), _dec3 = common.Bind(), (_class = class RunScriptRoutine extends RunInWorkspacesRoutine.RunInWorkspacesRoutine {
  constructor(...args) {
    super(...args);
    this.errors = [];
  }

  async getInitialValue(context) {
    const tool = this.options.tool;
    return this.createWaterfallPipeline(context).pipe(tool.msg('app:scriptLoad'), this.loadScriptFromTool).pipe(tool.msg('app:scriptLoadModule'), this.loadScriptFromModule).pipe(tool.msg('app:scriptLoadPost'), this.postLoad).run();
  }

  pipeRoutine(context, packageName, packageRoot) {
    const argv = context.argv,
          cwd = context.cwd,
          scriptName = context.scriptName;

    const _filterArgs$filterArg = filterArgs.filterArgs(argv, {
      block: constants.EXECUTE_OPTIONS
    }),
          filteredArgv = _filterArgs$filterArg.filteredArgv;

    const command = filteredArgv.join(' ');

    if (packageName) {
      this.routines.push(new ExecuteScriptRoutine.ExecuteScriptRoutine(packageName, command, {
        packageRoot,
        tool: this.options.tool
      }));
    } else {
      this.routines.push(new ExecuteScriptRoutine.ExecuteScriptRoutine(scriptName, command, {
        packageRoot: cwd.path(),
        tool: this.options.tool
      }));
    }
  }
  /**
   * If the script has been loaded into the tool, return that directly.
   * Scripts can be preloaded from a configuration file or the command line.
   */


  loadScriptFromTool(context) {
    this.debug('Attempting to load script from tool');

    try {
      const script = this.options.tool.scriptRegistry.get(context.scriptName);
      context.setScript(script);
      return script;
    } catch (error) {
      if (common.instanceOf(error, Error)) {
        this.errors.push(new Error(this.options.tool.msg('app:fromTool', {
          message: error.message
        })));
      }

      return null;
    }
  }
  /**
   * Attempt to load a script from the configuration module's `scripts/` folder,
   * or a standard Node modules folder.
   */


  async loadScriptFromModule(context, script) {
    if (script) {
      return script;
    }

    this.debug('Attempting to load script from configuration module or node module');
    const tool = this.options.tool;
    const moduleName = tool.config.module;
    const fileName = upperFirst__default["default"](camelCase__default["default"](context.scriptName));
    const resolver = new common.PathResolver();

    if (moduleName === '@local') {
      const root = context.configModuleRoot;
      resolver.lookupFilePath(`scripts/${fileName}.ts`, root).lookupFilePath(`scripts/${fileName}.js`, root).lookupFilePath(`src/scripts/${fileName}.ts`, root).lookupFilePath(`lib/scripts/${fileName}.js`, root);
    } else {
      resolver.lookupNodeModule(`${moduleName}/scripts/${fileName}.ts`).lookupNodeModule(`${moduleName}/scripts/${fileName}.js`).lookupNodeModule(`${moduleName}/src/scripts/${fileName}.ts`).lookupNodeModule(`${moduleName}/lib/scripts/${fileName}.js`).lookupNodeModule(tool.scriptRegistry.formatModuleName(context.scriptName, true)).lookupNodeModule(tool.scriptRegistry.formatModuleName(context.scriptName));
    }

    try {
      const _resolver$resolve = resolver.resolve(),
            resolvedPath = _resolver$resolve.resolvedPath;

      const loadedScript = await tool.scriptRegistry.load(resolvedPath.path(), undefined, {
        tool: this.options.tool
      });
      context.setScript(loadedScript);
      return loadedScript;
    } catch (error) {
      if (common.instanceOf(error, Error)) {
        this.errors.push(new Error(tool.msg('app:fromModule', {
          message: error.message
        })));
      }

      return null;
    }
  }
  /**
   * If all of the loading patterns have failed, thrown an error,
   * otherwise add the script and continue.
   */


  postLoad(context, script) {
    if (!script) {
      const messages = this.errors.map(error => `  - ${error.message}`).join('\n');
      throw new Error(`Failed to load script from multiple sources:\n${messages}`);
    }

    void this.options.tool.scriptRegistry.load(script, undefined, {
      tool: this.options.tool
    });
    return script;
  }

}, (_rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "loadScriptFromTool", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "loadScriptFromTool"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "loadScriptFromModule", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "loadScriptFromModule"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "postLoad", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "postLoad"), _class.prototype)), _class));
exports.RunScriptRoutine = RunScriptRoutine;
//# sourceMappingURL=RunScriptRoutine.js.map
