'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const internal = require('@boost/internal');

const pipeline = require('@boost/pipeline');

const CreateConfigRoutine = require('./CreateConfigRoutine.js');

class ResolveConfigsRoutine extends pipeline.Routine {
  blueprint({
    instance
  }) {
    return {
      tool: instance().required().notNullable()
    };
  }

  async execute(context) {
    this.resolveDependencies(context);
    const routines = this.setupConfigFiles(context); // Parallel

    if (this.options.tool.config.configure.parallel) {
      const pipeline = routines.reduce((pl, routine) => pl.add(routine), this.createConcurrentPipeline(context));
      return pipeline.run();
    } // Serial


    const pipeline = routines.reduce((pl, routine) => pl.pipe(routine), this.createWaterfallPipeline(context));
    return [await pipeline.run()];
  }
  /**
   * Pipe a routine for every driver we need to create a configuration for,
   * and then run in parallel.
   */


  setupConfigFiles(context) {
    const names = [];
    const routines = [...context.drivers].reverse().map(driver => {
      names.push(driver.getName());
      return new CreateConfigRoutine.CreateConfigRoutine(driver.getName(), driver.metadata.configName, {
        driver,
        tool: this.options.tool
      });
    });
    this.debug('Creating config files for the following drivers: %s', internal.color.symbol(names.join(', ')));
    return routines;
  }
  /**
   * Recursively loop through an driver's dependencies, adding a dependenct driver for each,
   * starting from the primary driver (the command that initiated the process).
   */


  resolveDependencies(context) {
    const tool = this.options.tool;
    const queue = [...context.drivers];
    this.debug('Resolving dependencies');

    while (queue.length > 0) {
      const driver = queue.shift();
      const deps = new Set(driver.getDependencies());
      this.debug('Resolving "%s"', driver.getName());
      deps.forEach(name => {
        this.debug('  Including dependency %s', internal.color.symbol(name));
        queue.push(tool.driverRegistry.get(name));
      });
      context.addDriverDependency(driver);
    }

    tool.onResolveDependencies.emit([context, [...context.drivers]]);
  }

}

exports.ResolveConfigsRoutine = ResolveConfigsRoutine;
//# sourceMappingURL=ResolveConfigsRoutine.js.map
