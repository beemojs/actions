'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');

const fs = require('fs-extra');

const camelCase = require('lodash/camelCase');

const common = require('@boost/common');

const internal = require('@boost/internal');

const module$1 = require('@boost/module');

const pipeline = require('@boost/pipeline');

const constants = require('../constants.js');

const Driver = require('../Driver.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

const fs__default = /*#__PURE__*/_interopDefault(fs);

const camelCase__default = /*#__PURE__*/_interopDefault(camelCase);

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class;

let CreateConfigRoutine = (_dec = common.Bind(), _dec2 = common.Bind(), _dec3 = common.Bind(), _dec4 = common.Bind(), _dec5 = common.Bind(), _dec6 = common.Bind(), _dec7 = common.Bind(), _dec8 = common.Bind(), (_class = class CreateConfigRoutine extends pipeline.Routine {
  blueprint({
    instance
  }) {
    return {
      // @ts-expect-error Errors because Driver is abstract
      driver: instance(Driver.Driver).required().notNullable(),
      tool: instance().required().notNullable()
    };
  }

  async execute(context) {
    const _this$options = this.options,
          driver = _this$options.driver,
          tool = _this$options.tool;
    const metadata = driver.metadata,
          options = driver.options;
    const name = metadata.title;
    const strategy = options.configStrategy === constants.STRATEGY_NATIVE ? metadata.configStrategy : options.configStrategy;

    switch (strategy) {
      case constants.STRATEGY_REFERENCE:
        return this.createWaterfallPipeline(context, []).pipe(tool.msg('app:configSetEnvVars', {
          name
        }), this.setEnvVars).pipe(tool.msg('app:configReference', {
          name
        }), this.referenceConfigFile).run();

      case constants.STRATEGY_COPY:
        return this.createWaterfallPipeline(context, []).pipe(tool.msg('app:configSetEnvVars', {
          name
        }), this.setEnvVars).pipe(tool.msg('app:configCopy', {
          name
        }), this.copyConfigFile).run();

      case constants.STRATEGY_CREATE:
        return this.createWaterfallPipeline(context, []).pipe(tool.msg('app:configSetEnvVars', {
          name
        }), this.setEnvVars).pipe(tool.msg('app:configCreateLoadProvider', {
          name
        }), this.loadConfigFromProvider).pipe(tool.msg('app:configCreateLoadConsumer', {
          name
        }), this.loadConfigFromConsumer).pipe(tool.msg('app:configCreateMerge', {
          name
        }), this.mergeConfigs).pipe(tool.msg('app:configCreate', {
          name
        }), this.createConfigFile).run();

      case constants.STRATEGY_TEMPLATE:
        return this.createWaterfallPipeline(context, []).pipe(tool.msg('app:configSetEnvVars', {
          name
        }), this.setEnvVars).pipe(tool.msg('app:configCreateLoadProvider', {
          name
        }), this.loadConfigFromProvider).pipe(tool.msg('app:configCreateLoadConsumer', {
          name
        }), this.loadConfigFromConsumer).pipe(tool.msg('app:configCreateFromTemplate', {
          name
        }), this.createConfigFileFromTemplate).run();

      default:
        this.skip(true);
        break;
    }

    return Promise.resolve(new common.Path());
  }
  /**
   * Copy configuration file from module.
   */


  async copyConfigFile(context) {
    const _this$options2 = this.options,
          driver = _this$options2.driver,
          tool = _this$options2.tool;
    const metadata = driver.metadata;
    const sourcePath = this.getConfigPath(context);
    const configPath = context.cwd.append(metadata.configName);

    if (!sourcePath) {
      throw new Error(tool.msg('errors:configCopySourceMissing'));
    }

    const config = this.loadConfigAtPath(sourcePath);
    this.debug('Copying config file to %s', internal.color.filePath(configPath));
    driver.config = config;
    driver.onCopyConfigFile.emit([context, configPath, config]);
    context.addConfigPath(driver.getName(), configPath);
    await fs__default["default"].copy(sourcePath.path(), configPath.path(), {
      overwrite: true
    });
    return configPath;
  }
  /**
   * Create a temporary configuration file or pass as an option.
   */


  async createConfigFile(context, config) {
    const driver = this.options.driver;
    const metadata = driver.metadata;
    const configPath = context.cwd.append(metadata.configName);
    this.debug('Creating config file %s', internal.color.filePath(configPath));
    driver.config = config;
    driver.onCreateConfigFile.emit([context, configPath, config]);
    context.addConfigPath(driver.getName(), configPath);
    await fs__default["default"].writeFile(configPath.path(), this.options.driver.formatConfig(config));
    return configPath;
  }
  /**
   * Create a configuration file for the defined driver based on a custom template
   * provided by the consumer.
   */


  async createConfigFileFromTemplate(context, configs) {
    const _this$options3 = this.options,
          driver = _this$options3.driver,
          tool = _this$options3.tool;
    const metadata = driver.metadata;
    const driverConfigPath = context.cwd.append(metadata.configName);
    const templatePath = common.Path.resolve(driver.options.template, context.cwd.append('.config'));
    let template;

    if (!driver.options.template) {
      throw new Error(tool.msg('errors:templateRequired'));
    }

    try {
      template = module$1.requireModule(templatePath).default;
    } catch {
      throw new Error(tool.msg('errors:templatePathMissing', {
        path: templatePath.name()
      }));
    }

    if (typeof template !== 'function') {
      throw new TypeError(tool.msg('errors:templateTypeInvalid', {
        type: typeof template
      }));
    }

    const _template = template(configs, {
      configModule: tool.config.module,
      consumerConfigPath: this.getConfigPath(context, true),
      context,
      driver,
      driverConfigPath,
      driverName: driver.getName(),
      providerConfigPath: this.getConfigPath(context),
      templatePath,
      tool
    }),
          config = _template.config,
          _template$path = _template.path,
          path = _template$path === void 0 ? driverConfigPath : _template$path; // Allow the config path to be altered


    const configPath = common.Path.resolve(path, context.cwd);
    context.addConfigPath(driver.getName(), configPath);
    driver.config = typeof config === 'string' ? {} : config;
    driver.onTemplateConfigFile.emit([context, configPath, config]);
    await fs__default["default"].writeFile(configPath.path(), typeof config === 'string' ? config : this.options.driver.formatConfig(config));
    return configPath;
  }
  /**
   * Return an absolute file path for a config file in either the consumer or provider.
   */


  getConfigPath({
    cwd,
    workspaceRoot
  }, fromConsumer = false) {
    const projectName = this.options.tool.options.projectName;
    const moduleName = this.options.tool.config.module;
    const driverName = this.options.driver.getName();
    const configName = camelCase__default["default"](driverName);
    const resolver = new common.PathResolver();
    const root = workspaceRoot || cwd;
    let debugMessage = ''; // When loading from the consumer (project in which beemo is running),
    // we look for config files in a `beemo` folder relative to the root
    // `.config/beemo.js` config file.

    if (fromConsumer) {
      debugMessage = `Loading ${internal.color.symbol(driverName)} config from local project as an override`;
      resolver.lookupFilePath(`.config/${projectName}/${configName}.ts`, root).lookupFilePath(`.config/${projectName}/${configName}.js`, root); // When loading from the provider (upstream configuratiob module),
      // we look for a config file in multiple places, in an attempt to
      // support both source and pre-built formats.
    } else {
      debugMessage = `Loading ${internal.color.symbol(driverName)} config from configuration module ${internal.color.moduleName(moduleName)}`; // If module name is @local, allow for local development
      // by looking for config files in the current project.

      if (moduleName === '@local') {
        resolver.lookupFilePath(`configs/${configName}.ts`, root).lookupFilePath(`configs/${configName}.js`, root).lookupFilePath(`src/configs/${configName}.ts`, root).lookupFilePath(`lib/configs/${configName}.js`, root);
      } else {
        resolver.lookupNodeModule(`${moduleName}/configs/${configName}.ts`).lookupNodeModule(`${moduleName}/configs/${configName}.js`).lookupNodeModule(`${moduleName}/src/configs/${configName}.ts`).lookupNodeModule(`${moduleName}/lib/configs/${configName}.js`);
      }
    }

    let configPath = null;

    try {
      configPath = resolver.resolvePath();
    } catch {// Ignore
    }

    this.debug.invariant(!!configPath, debugMessage, 'Exists, loading', 'Does not exist, skipping');

    if (configPath) {
      this.debug('Found at %s', internal.color.filePath(configPath));
    }

    return configPath;
  }
  /**
   * Merge multiple configuration sources using the current driver.
   */


  async mergeConfigs(context, configs) {
    const driver = this.options.driver;
    this.debug('Merging %s config from %d sources', internal.color.symbol(driver.getName()), configs.length); // eslint-disable-next-line unicorn/prefer-object-from-entries

    const config = configs.reduce((masterConfig, cfg) => this.options.driver.mergeConfig(masterConfig, cfg), {});
    driver.onMergeConfig.emit([context, config]);
    return Promise.resolve(config);
  }
  /**
   * Load a config file with passing the args and tool to the file.
   */


  loadConfigAtPath(filePath) {
    const config = module$1.requireModule(filePath).default;

    if (typeof config === 'function') {
      throw new TypeError(this.options.tool.msg('errors:configNoFunction', {
        name: filePath.name()
      }));
    }

    return config;
  }
  /**
   * Load config from the consumer / local overrides.
   */


  async loadConfigFromConsumer(context, prevConfigs) {
    const sourcePath = this.getConfigPath(context, true);
    const configs = [...prevConfigs];

    if (sourcePath) {
      const config = this.loadConfigAtPath(sourcePath);
      configs.push(config);
      this.options.driver.onLoadConsumerConfig.emit([context, config]);
    }

    return Promise.resolve(configs);
  }
  /**
   * Load config from the provider / configuration module.
   */


  async loadConfigFromProvider(context, prevConfigs) {
    const sourcePath = this.getConfigPath(context);
    const configs = [...prevConfigs];

    if (sourcePath) {
      const config = this.loadConfigAtPath(sourcePath);
      configs.push(config);
      this.options.driver.onLoadProviderConfig.emit([context, sourcePath, config]);
    }

    return Promise.resolve(configs);
  }
  /**
   * Reference configuration file from module using a require statement.
   */


  async referenceConfigFile(context) {
    const _this$options4 = this.options,
          driver = _this$options4.driver,
          tool = _this$options4.tool;
    const metadata = driver.metadata;
    const sourcePath = this.getConfigPath(context);
    const configPath = context.cwd.append(metadata.configName);

    if (!sourcePath) {
      throw new Error(tool.msg('errors:configReferenceSourceMissing'));
    }

    const config = this.loadConfigAtPath(sourcePath);
    this.debug('Referencing config file to %s', internal.color.filePath(configPath));
    driver.config = config;
    driver.onReferenceConfigFile.emit([context, configPath, config]);
    context.addConfigPath(driver.getName(), configPath);
    const requirePath = context.cwd.relativeTo(sourcePath);
    await fs__default["default"].writeFile(configPath.path(), `module.exports = require('./${requirePath}');`);
    return configPath;
  }
  /**
   * Set environment variables defined by the driver.
   */


  setEnvVars(context, configs) {
    const env = this.options.driver.options.env; // TODO: This may cause collisions, isolate somehow?

    Object.keys(env).forEach(key => {
      process.env[key] = env[key];
    });
    return configs;
  }

}, (_rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "copyConfigFile", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "copyConfigFile"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "createConfigFile", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "createConfigFile"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "createConfigFileFromTemplate", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "createConfigFileFromTemplate"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "mergeConfigs", [_dec4], Object.getOwnPropertyDescriptor(_class.prototype, "mergeConfigs"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "loadConfigFromConsumer", [_dec5], Object.getOwnPropertyDescriptor(_class.prototype, "loadConfigFromConsumer"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "loadConfigFromProvider", [_dec6], Object.getOwnPropertyDescriptor(_class.prototype, "loadConfigFromProvider"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "referenceConfigFile", [_dec7], Object.getOwnPropertyDescriptor(_class.prototype, "referenceConfigFile"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "setEnvVars", [_dec8], Object.getOwnPropertyDescriptor(_class.prototype, "setEnvVars"), _class.prototype)), _class));
exports.CreateConfigRoutine = CreateConfigRoutine;
//# sourceMappingURL=CreateConfigRoutine.js.map
