'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const rimraf = require('rimraf');

const core = require('@beemo/core');

const event = require('@boost/event');

const syncProjectRefs = require('./commands/syncProjectRefs.js');

const helpers = require('./helpers.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

const rimraf__default = /*#__PURE__*/_interopDefault(rimraf);
/* eslint-disable no-param-reassign */
// Success: Writes nothing to stdout or stderr
// Failure: Writes to stdout on syntax and type error


class TypeScriptDriver extends core.Driver {
  constructor(...args) {
    super(...args);
    this.name = '@beemo/driver-typescript';
    this.onCreateProjectConfigFile = new event.Event('create-project-config-file');

    this.handleCleanTarget = context => {
      var _this$config$compiler;

      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      const outDir = context.getRiskyOption('outDir', true) || ((_this$config$compiler = this.config.compilerOptions) === null || _this$config$compiler === void 0 ? void 0 : _this$config$compiler.outDir);

      if (context.getRiskyOption('clean') && typeof outDir === 'string' && outDir) {
        rimraf__default['default'].sync(core.Path.resolve(outDir).path());
      }

      return Promise.resolve();
    };

    this.handlePrepareConfigs = (context, configPath, config) => {
      const tool = this.tool;
      const _this$options = this.options,
            srcFolder = _this$options.srcFolder,
            testsFolder = _this$options.testsFolder;
      const workspacePackages = tool.project.getWorkspacePackages();

      if (workspacePackages.length === 0) {
        return;
      } // Extract compiler optionst to a separate config


      const optionsConfigPath = configPath.parent().append('tsconfig.options.json');
      void helpers.writeFile(optionsConfigPath, {
        compilerOptions: _objectSpread(_objectSpread({}, config.compilerOptions), {}, {
          composite: true,
          declaration: true,
          declarationMap: true,
          outDir: undefined,
          outFile: undefined
        })
      }); // Delete problematic root options

      delete config.compilerOptions;
      delete config.include;
      delete config.exclude; // Generate references and update paths

      config.extends = './tsconfig.options.json';
      config.files = [];
      config.references || (config.references = []);
      workspacePackages.forEach(({
        metadata
      }) => {
        const pkgPath = new core.Path(metadata.packagePath);
        const srcPath = pkgPath.append(srcFolder);
        const testsPath = pkgPath.append(testsFolder); // Reference a package *only* if it has a src folder

        if (srcFolder && srcPath.exists()) {
          config.references.push({
            path: tool.project.root.relativeTo(pkgPath).path()
          }); // Reference a separate tests folder if it exists

          if (testsFolder && testsPath.exists()) {
            config.references.push({
              path: tool.project.root.relativeTo(testsPath).path()
            });
          }
        }
      }); // Add to context so that it can be automatically cleaned up

      context.addConfigPath('typescript', optionsConfigPath);
    };
  }

  blueprint(preds) {
    const bool = preds.bool,
          string = preds.string;
    return _objectSpread(_objectSpread({}, super.blueprint(preds)), {}, {
      buildFolder: string('lib'),
      declarationOnly: bool(),
      globalTypes: bool(true),
      localTypes: bool(true),
      srcFolder: string('src'),
      testsFolder: string('tests'),
      typesFolder: string('types')
    });
  }

  bootstrap() {
    this.setMetadata({
      bin: 'tsc',
      commandOptions: {
        clean: {
          default: false,
          description: this.tool.msg('app:typescriptCleanOption'),
          type: 'boolean'
        }
      },
      configName: 'tsconfig.json',
      configOption: '',
      description: this.tool.msg('app:typescriptDescription'),
      helpOption: '--help --all',
      title: 'TypeScript',
      watchOptions: ['-w', '--watch'],
      workspaceStrategy: 'copy'
    });
    this.registerCommand('sync-project-refs', {
      description: this.tool.msg('app:typescriptSyncProjectRefsDescription')
    }, syncProjectRefs.syncProjectRefs);
    this.onCreateConfigFile.listen(this.handlePrepareConfigs);
    this.onBeforeExecute.listen(this.handleCleanTarget);
  }
  /**
   * Automatically clean the target folder if `outDir` and `--clean` is used.
   */


}

exports.TypeScriptDriver = TypeScriptDriver;
//# sourceMappingURL=TypeScriptDriver.js.map
