'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const core = require('@beemo/core');

const helpers = require('../helpers.js');
/**
 * Create a `tsconfig.json` in each workspace package. Automatically link packages
 * together using project references. Attempt to handle source and test folders.
 */


async function syncProjectRefs(tool) {
  const driver = tool.driverRegistry.get('typescript');
  const root = tool.project.root;
  const _driver$options = driver.options,
        buildFolder = _driver$options.buildFolder,
        declarationOnly = _driver$options.declarationOnly,
        srcFolder = _driver$options.srcFolder,
        testsFolder = _driver$options.testsFolder,
        typesFolder = _driver$options.typesFolder,
        globalTypes = _driver$options.globalTypes,
        localTypes = _driver$options.localTypes;
  const optionsConfigPath = root.append('tsconfig.options.json');
  const globalTypesPath = root.append(typesFolder, '**/*');
  const namesToPaths = {};
  const workspacePackages = tool.project.getWorkspacePackages(); // Map package name to absolute paths

  workspacePackages.forEach(wsPkg => {
    namesToPaths[wsPkg.package.name] = wsPkg.metadata.packagePath;
  }); // Create a config file in each package

  await Promise.all(workspacePackages.map( // eslint-disable-next-line complexity
  ({
    package: {
      dependencies = {},
      devDependencies = {},
      peerDependencies = {},
      tsconfig = {}
    },
    metadata: workspace
  }) => {
    const pkgPath = new core.Path(workspace.packagePath);
    const srcPath = pkgPath.append(srcFolder);
    const testsPath = pkgPath.append(testsFolder);
    const references = [];
    const promises = []; // Extract and determine references

    Object.keys(_objectSpread(_objectSpread(_objectSpread({}, dependencies), devDependencies), peerDependencies)).forEach(depName => {
      if (namesToPaths[depName]) {
        references.push({
          path: pkgPath.relativeTo(namesToPaths[depName]).path()
        });
      }
    }); // Build package config

    if (srcFolder && srcPath.exists()) {
      const packageConfig = {
        compilerOptions: _objectSpread(_objectSpread({}, tsconfig.compilerOptions), {}, {
          declarationDir: buildFolder,
          outDir: buildFolder,
          rootDir: srcFolder
        }),
        exclude: [buildFolder],
        extends: pkgPath.relativeTo(optionsConfigPath).path(),
        include: [helpers.join(srcFolder, '**/*')],
        references
      };

      if (declarationOnly) {
        packageConfig.compilerOptions.emitDeclarationOnly = true;
      }

      if (localTypes) {
        packageConfig.include.push(helpers.join(typesFolder, '**/*'));
      }

      if (globalTypes) {
        packageConfig.include.push(pkgPath.relativeTo(globalTypesPath).path());
      }

      if (testsFolder) {
        packageConfig.exclude.push(testsFolder);
      }

      if (Array.isArray(tsconfig.include)) {
        packageConfig.include.push(...tsconfig.include);
      }

      if (Array.isArray(tsconfig.exclude)) {
        packageConfig.exclude.push(...tsconfig.exclude);
      }

      const configPath = pkgPath.append('tsconfig.json');
      driver.onCreateProjectConfigFile.emit([configPath, packageConfig, false]);
      promises.push(helpers.writeFile(configPath, packageConfig));
    } // Build tests specific package config


    if (testsFolder && testsPath.exists()) {
      const testConfig = {
        compilerOptions: {
          composite: false,
          emitDeclarationOnly: false,
          noEmit: true,
          rootDir: '.'
        },
        extends: testsPath.relativeTo(optionsConfigPath).path(),
        include: ['**/*'],
        references: [{
          path: '..'
        }]
      };

      if (localTypes) {
        testConfig.include.push(helpers.join('..', typesFolder, '**/*'));
      }

      if (globalTypes) {
        testConfig.include.push(testsPath.relativeTo(globalTypesPath).path());
      }

      const configPath = testsPath.append('tsconfig.json');
      driver.onCreateProjectConfigFile.emit([configPath, testConfig, true]);
      promises.push(helpers.writeFile(testsPath.append('tsconfig.json'), testConfig));
    }

    return Promise.all(promises);
  }));
}

exports.syncProjectRefs = syncProjectRefs;
//# sourceMappingURL=syncProjectRefs.js.map
