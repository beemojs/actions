'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');

const glob = require('fast-glob');

const fs = require('fs-extra');

const common = require('@boost/common');

const debug = require('@boost/debug');

const CodeArtifact = require('./CodeArtifact.js');

const constants = require('./constants.js');

const loadModule = require('./helpers/loadModule.js');

const schemas = require('./schemas.js');

const TypesArtifact = require('./TypesArtifact.js');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const glob__default = /*#__PURE__*/_interopDefault(glob);

const fs__default = /*#__PURE__*/_interopDefault(fs);

var _dec, _dec2, _dec3, _class;

let Package = (_dec = common.Memoize(), _dec2 = common.Memoize(), _dec3 = common.Memoize(), (_class = class Package {
  constructor(project, path, contents) {
    this.artifacts = [];
    this.configs = [];
    this.debug = void 0;
    this.packageJson = void 0;
    this.packageJsonPath = void 0;
    this.path = void 0;
    this.project = void 0;
    this.root = false;
    this.project = project;
    this.path = path;
    this.packageJsonPath = this.path.append('package.json');
    this.packageJson = contents;
    this.debug = debug.createDebugger(['packemon', 'package', this.getSlug()]);
  }

  addArtifact(artifact) {
    this.artifacts.push(artifact);
    artifact.startup();
    return artifact;
  }

  async build(options) {
    this.debug('Building artifacts'); // Build artifacts in parallel

    await Promise.all(this.artifacts.map(async artifact => {
      const start = Date.now();

      try {
        artifact.state = 'building';
        await artifact.build(options);
        artifact.state = 'passed';
      } catch (error) {
        artifact.state = 'failed';
        throw error;
      } finally {
        artifact.buildResult.time = Date.now() - start;
      }
    })); // Add package entry points based on artifacts

    this.addEntryPoints(); // Add package `engines` based on artifacts

    if (options.addEngines) {
      this.addEngines();
    } // Add package `exports` based on artifacts


    if (options.addExports) {
      this.addExports();
    } // Sync `package.json` in case it was modified


    await this.syncPackageJson();
  }

  async cleanup() {
    this.debug('Cleaning build artifacts');
    await Promise.all(this.artifacts.map(artifact => artifact.cleanup()));
  }

  getName() {
    return this.packageJson.name;
  } // eslint-disable-next-line complexity


  getFeatureFlags() {
    var _this$tsconfigJson;

    this.debug('Loading feature flags');
    const flags = this.root || !this.project.isWorkspacesEnabled() ? {} : this.project.rootPackage.getFeatureFlags();
    flags.workspaces = this.project.workspaces; // React

    if (this.project.rootPackage.hasDependency('react') || this.hasDependency('react')) {
      flags.react = true;
      this.debug(' - React');
    } // TypeScript


    const tsConfig = (_this$tsconfigJson = this.tsconfigJson) !== null && _this$tsconfigJson !== void 0 ? _this$tsconfigJson : this.project.rootPackage.tsconfigJson;

    if (this.project.rootPackage.hasDependency('typescript') || this.hasDependency('typescript') || tsConfig) {
      flags.typescript = true;
      flags.decorators = Boolean(tsConfig === null || tsConfig === void 0 ? void 0 : tsConfig.options.experimentalDecorators);
      flags.strict = Boolean(tsConfig === null || tsConfig === void 0 ? void 0 : tsConfig.options.strict);
      this.debug(' - TypeScript (%s, %s)', flags.strict ? 'strict' : 'non-strict', flags.decorators ? 'decorators' : 'non-decorators');
    } // Flow


    const flowconfigPath = this.project.root.append('.flowconfig');

    if (this.project.rootPackage.hasDependency('flow-bin') || this.hasDependency('flow-bin') || flowconfigPath.exists()) {
      flags.flow = true;
      this.debug(' - Flow');
    }

    return flags;
  }

  getSlug() {
    return this.path.name(true);
  }

  getSourceFiles() {
    return glob__default.default.sync('src/**/*.{js,jsx,ts,tsx}', {
      absolute: true,
      cwd: this.path.path(),
      onlyFiles: true
    });
  }

  hasDependency(name) {
    var _ref, _ref2, _pkg$dependencies$nam, _pkg$dependencies, _pkg$devDependencies, _pkg$peerDependencies, _pkg$optionalDependen;

    const pkg = this.packageJson;
    return Boolean((_ref = (_ref2 = (_pkg$dependencies$nam = (_pkg$dependencies = pkg.dependencies) === null || _pkg$dependencies === void 0 ? void 0 : _pkg$dependencies[name]) !== null && _pkg$dependencies$nam !== void 0 ? _pkg$dependencies$nam : (_pkg$devDependencies = pkg.devDependencies) === null || _pkg$devDependencies === void 0 ? void 0 : _pkg$devDependencies[name]) !== null && _ref2 !== void 0 ? _ref2 : (_pkg$peerDependencies = pkg.peerDependencies) === null || _pkg$peerDependencies === void 0 ? void 0 : _pkg$peerDependencies[name]) !== null && _ref !== void 0 ? _ref : (_pkg$optionalDependen = pkg.optionalDependencies) === null || _pkg$optionalDependen === void 0 ? void 0 : _pkg$optionalDependen[name]);
  }

  isComplete() {
    return this.artifacts.every(artifact => artifact.isComplete());
  }

  isRunning() {
    return this.artifacts.some(artifact => artifact.isRunning());
  }

  setConfigs(configs) {
    configs.forEach(cfg => {
      const config = common.optimal(cfg, schemas.packemonBlueprint, {
        name: this.getName()
      });
      common.toArray(config.platform).forEach(platform => {
        let bundle = config.bundle;
        let formats = [...common.toArray(config.format)];
        const isEmpty = formats.length === 0;

        switch (platform) {
          case 'native':
            if (isEmpty) {
              formats.push(...constants.DEFAULT_FORMATS.native);
            } else {
              formats = formats.filter(format => constants.FORMATS_NATIVE.includes(format));
            }

            break;

          case 'node':
            if (cfg.bundle === undefined) {
              bundle = false;
            }

            if (isEmpty) {
              formats.push(...constants.DEFAULT_FORMATS.node);
            } else {
              formats = formats.filter(format => constants.FORMATS_NODE.includes(format));
            }

            break;

          case 'browser':
          default:
            if (isEmpty) {
              formats.push(...constants.DEFAULT_FORMATS.browser);

              if (config.namespace) {
                formats.push('umd');
              }
            } else {
              formats = formats.filter(format => constants.FORMATS_BROWSER.includes(format));
            }

            break;
        }

        this.configs.push({
          bundle,
          externals: common.toArray(config.externals),
          formats,
          inputs: config.inputs,
          namespace: config.namespace,
          platform,
          support: config.support
        });
      });
    });
  }

  async syncPackageJson() {
    await fs__default.default.writeJson(this.packageJsonPath.path(), this.packageJson, {
      spaces: 2
    });
  }

  get tsconfigJson() {
    const tsconfigJsonPath = this.path.append('tsconfig.json');

    if (!tsconfigJsonPath.exists()) {
      return undefined;
    }

    const ts = loadModule.loadModule('typescript', 'TypeScript is required for config loading.'); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    const _ts$readConfigFile = ts.readConfigFile(tsconfigJsonPath.path(), name => fs__default.default.readFileSync(name, 'utf8')),
          config = _ts$readConfigFile.config,
          error = _ts$readConfigFile.error;

    const host = {
      getCanonicalFileName: fileName => fileName,
      getCurrentDirectory: () => ts.sys.getCurrentDirectory(),
      getNewLine: () => ts.sys.newLine
    }; // istanbul ignore next

    if (error) {
      throw new Error(ts.formatDiagnostic(error, host));
    }

    const result = ts.parseJsonConfigFileContent(config, ts.sys, this.path.path(), {}, tsconfigJsonPath.path()); // istanbul ignore next

    if (result.errors.length > 0) {
      throw new Error(ts.formatDiagnostics(result.errors, host));
    }

    return result;
  }

  addEngines() {
    const artifact = this.artifacts.filter(art => art instanceof CodeArtifact.CodeArtifact).filter(art => art.platform === 'node').reduce((oldest, art) => !oldest || constants.SUPPORT_PRIORITY[art.support] < constants.SUPPORT_PRIORITY[oldest.support] ? art : oldest, null);

    if (!artifact) {
      return;
    }

    this.debug('Adding `engines` to `package.json`');
    const pkg = this.packageJson;

    if (!pkg.engines) {
      pkg.engines = {};
    }

    Object.assign(pkg.engines, {
      node: `>=${constants.NODE_SUPPORTED_VERSIONS[artifact.support]}`,
      npm: common.toArray(constants.NPM_SUPPORTED_VERSIONS[artifact.support]).map(v => `>=${v}`).join(' || ')
    });
  }

  addEntryPoints() {
    this.debug('Adding entry points to `package.json`');
    let mainEntry = '';
    let moduleEntry = '';
    let browserEntry = '';
    const files = new Set(this.packageJson.files); // eslint-disable-next-line complexity

    this.artifacts.forEach(artifact => {
      // Build files
      if (artifact instanceof CodeArtifact.CodeArtifact) {
        // Generate `main`, `module`, and `browser` fields
        if (artifact.inputs.index) {
          if (!mainEntry || artifact.platform === 'node') {
            mainEntry = artifact.findEntryPoint(['lib', 'cjs', 'mjs', 'esm'], 'index');
          }

          if (!moduleEntry) {
            moduleEntry = artifact.findEntryPoint(['esm', 'mjs'], 'index');
          } // Only include when we share a lib with another platform


          if (!browserEntry && artifact.platform === 'browser') {
            browserEntry = artifact.findEntryPoint(artifact.sharedLib ? ['lib', 'umd'] : ['umd'], 'index');
          }
        } // Generate `bin` field


        if (artifact.inputs.bin && artifact.platform === 'node' && !common.isObject(this.packageJson.bin)) {
          this.packageJson.bin = artifact.findEntryPoint(['lib', 'cjs', 'mjs'], 'bin');
        } // Generate `files` list


        artifact.builds.forEach(({
          format
        }) => {
          files.add(`${format}/**/*.{${artifact.getBuildOutput(format).ext},map}`);
        });
        files.add(`src/**/*.{${this.getSourceFileExts(artifact.inputs)}}`);
      } // Type declarations


      if (artifact instanceof TypesArtifact.TypesArtifact) {
        this.packageJson.types = artifact.findEntryPoint('index');
        files.add('dts/**/*.d.ts');
      }
    });

    if (mainEntry) {
      this.packageJson.main = mainEntry;

      if (mainEntry.includes('mjs/') || mainEntry.includes('esm/')) {
        this.packageJson.type = 'module';
      } else if (mainEntry.includes('cjs/')) {
        this.packageJson.type = 'commonjs';
      }
    }

    if (moduleEntry) {
      this.packageJson.module = moduleEntry;
    }

    if (browserEntry && !common.isObject(this.packageJson.browser)) {
      this.packageJson.browser = browserEntry;
    }

    this.packageJson.files = [...files].sort();
  }

  addExports() {
    this.debug('Adding `exports` to `package.json`');
    const exportMap = {
      './package.json': './package.json'
    };
    this.artifacts.forEach(artifact => {
      Object.entries(artifact.getPackageExports()).forEach(([basePath, conditions]) => {
        const path = basePath.replace('/index', '');

        if (!exportMap[path]) {
          exportMap[path] = {};
        } else if (typeof exportMap[path] === 'string') {
          exportMap[path] = {
            default: exportMap[path]
          };
        }

        Object.assign(exportMap[path], conditions);
      });
    });

    if (common.isObject(this.packageJson.exports)) {
      Object.assign(this.packageJson.exports, exportMap);
    } else {
      this.packageJson.exports = exportMap;
    }
  }

  getSourceFileExts(inputs) {
    const sourceExts = Object.values(inputs).map(inputFile => new common.Path(inputFile).ext(true));
    const exts = new Set(sourceExts); // Include sibling file extensions

    sourceExts.forEach(sourceExt => {
      switch (sourceExt) {
        case 'js':
          exts.add('jsx');
          break;

        case 'jsx':
        case 'cjs':
          exts.add('js');
          break;

        case 'ts':
          exts.add('tsx');
          break;

        case 'tsx':
          exts.add('ts');
          break;
        // no default
      }
    });
    const list = [...exts].sort(); // Always be last

    list.push('json');
    return list;
  }

}, (_rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "getFeatureFlags", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "getFeatureFlags"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "getSourceFiles", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "getSourceFiles"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "tsconfigJson", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "tsconfigJson"), _class.prototype)), _class));
exports.Package = Package;
//# sourceMappingURL=Package.js.map
