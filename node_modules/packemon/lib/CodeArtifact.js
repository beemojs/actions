'use strict';

const _excluded = ["output"],
      _excluded2 = ["originalFormat"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const rollup = require('rollup');

const common = require('@boost/common');

const debug = require('@boost/debug');

const Artifact = require('./Artifact.js');

const removeSourcePath = require('./helpers/removeSourcePath.js');

const config = require('./rollup/config.js');

class CodeArtifact extends Artifact.Artifact {
  constructor(...args) {
    super(...args);
    this.bundle = true;
    this.cache = void 0;
    this.configGroup = 0;
    this.externals = [];
    this.inputs = {};
    this.namespace = '';
    this.platform = 'node';
    this.sharedLib = false;
    this.support = 'stable';
    this.debug = void 0;
  }

  startup() {
    this.debug = debug.createDebugger(['packemon', 'code', this.package.getSlug(), this.getLabel()]);
  }

  async cleanup() {
    this.debug('Cleaning code artifacts'); // Visualizer stats

    await this.removeFiles([this.package.project.root.append(this.getStatsFileName())]);
  }

  async build(options) {
    this.debug('Building code artifacts with Rollup');
    const features = this.package.getFeatureFlags();

    if (options.analyze !== 'none') {
      features.analyze = options.analyze;
    }

    const _config$getRollupConf = config.getRollupConfig(this, features),
          _config$getRollupConf2 = _config$getRollupConf.output,
          output = _config$getRollupConf2 === void 0 ? [] : _config$getRollupConf2,
          input = _objectWithoutProperties(_config$getRollupConf, _excluded);

    const bundle = await rollup.rollup(_objectSpread(_objectSpread({}, input), {}, {
      onwarn:
      /* istanbul ignore next */
      ({
        id,
        loc = {},
        message
      }) => {
        this.logWithSource(message, 'warn', {
          id: id && id !== loc.file ? id : undefined,
          output: this.package.getSlug(),
          sourceColumn: loc.column,
          sourceFile: loc.file,
          sourceLine: loc.line
        });
      }
    }));

    if (bundle.cache) {
      this.cache = bundle.cache;
    }

    const files = [];
    await Promise.all(common.toArray(output).map(async (out, index) => {
      const _out$originalFormat = out.originalFormat,
            originalFormat = _out$originalFormat === void 0 ? 'lib' : _out$originalFormat,
            outOptions = _objectWithoutProperties(out, _excluded2);

      this.debug(' - Writing `%s` output', originalFormat); // While testing we want to avoid writing files,
      // so use generate() instead of write():
      // https://github.com/rollup/rollup/issues/4082

      const result = process.env.NODE_ENV === 'test' ? await bundle.generate(outOptions) : await bundle.write(outOptions); // Update build results and stats

      const bundledCode = result.output.reduce((code, chunk) => {
        if (chunk.type === 'chunk') {
          files.push({
            code: chunk.code,
            file: `${originalFormat}/${chunk.fileName}`
          });
          return code + chunk.code;
        }

        return code;
      }, '');
      this.builds[index].stats = {
        size: Buffer.byteLength(bundledCode)
      };
      return result;
    }));
    this.buildResult.files = files;
  }

  findEntryPoint(formats, outputName) {
    for (const format of formats) {
      if (this.builds.some(build => build.format === format)) {
        return this.getBuildOutput(format, outputName).path;
      }
    }

    return '';
  }

  getBuildOutput(format, outputName = '') {
    let name = outputName; // When not bundling, we do not create output files based on the input map.
    // Instead files mirror the source file structure, so we need to take that into account!

    if (!this.bundle && this.inputs[outputName]) {
      name = removeSourcePath.removeSourcePath(this.inputs[outputName]);
    }

    const ext = format === 'cjs' || format === 'mjs' ? format : 'js';
    const folder = format === 'lib' && this.sharedLib ? `lib/${this.platform}` : format;
    const file = `${name}.${ext}`;
    return {
      ext,
      file,
      folder,
      path: `./${new common.Path(folder, file)}`
    };
  }

  getBuildTargets() {
    return this.builds.map(build => build.format);
  }

  getInputPaths() {
    // Return absolute paths so that Rollup paths/externals resolve correctly
    return Object.fromEntries(Object.entries(this.inputs).map(([outputName, inputFile]) => [outputName, this.package.path.append(inputFile).path()]));
  }

  getLabel() {
    return `${this.platform}:${this.support}:${this.getBuildTargets().join(',')}`;
  }

  getPackageExports() {
    const exportMap = {};
    Object.keys(this.inputs).forEach(outputName => {
      const paths = {};
      let libPath = '';
      this.builds.forEach(({
        format
      }) => {
        const entry = this.findEntryPoint([format], outputName);

        switch (format) {
          case 'mjs':
          case 'esm':
            paths.import = entry; // Webpack and Rollup support

            if (format === 'esm') {
              paths.module = entry;
            }

            break;

          case 'cjs':
            paths.require = entry;
            break;

          case 'lib':
            libPath = entry;
            break;

          default:
            break;
        }
      }); // Must come after import/require

      if (libPath) {
        paths.default = libPath;
      }

      exportMap[`./${outputName}`] = {
        [this.platform === 'native' ? 'react-native' : this.platform]: Object.keys(paths).length === 1 && libPath ? paths.default : paths
      };
    });
    return exportMap;
  }

  getStatsFileName() {
    return `stats-${this.getStatsTitle().replace(/\//gu, '-')}.html`;
  }

  getStatsTitle() {
    return `${this.package.getName()}/${this.platform}/${this.support}`;
  }

  toString() {
    return `code (${this.getLabel()})`;
  }

}

exports.CodeArtifact = CodeArtifact;
//# sourceMappingURL=CodeArtifact.js.map
