'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');

const cli = require('@boost/cli');

const common = require('@boost/common');

const loadModule = require('../helpers/loadModule.js');

const Base = require('./Base.js');

var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2;

let WatchCommand = (_dec = cli.Config('watch', 'Watch local files for changes and rebuild'), _dec2 = cli.Arg.Number('Number of milliseconds to wait after a change before triggering a rebuild'), _dec3 = cli.Arg.Flag('Poll for file changes instead of using file system events'), _dec4 = common.Bind(), _dec(_class = (_class2 = class WatchCommand extends Base.BaseCommand {
  constructor(...args) {
    super(...args);

    _rollupPluginBabelHelpers.initializerDefineProperty(this, "debounce", _descriptor, this);

    _rollupPluginBabelHelpers.initializerDefineProperty(this, "poll", _descriptor2, this);

    this.packages = [];
    this.packagesToRebuild = new Set();
    this.rebuilding = false;
    this.rebuildTimer = void 0;
  }

  enqueueRebuild(event, path) {
    if (event !== 'add' && event !== 'change' && event !== 'unlink') {
      return;
    }

    this.log(cli.applyStyle(' - %s', 'muted'), path.replace(`${this.packemon.root.path()}/`, ''));
    const changedPkg = this.packages.find(pkg => path.startsWith(pkg.path.path()));

    if (changedPkg) {
      this.packagesToRebuild.add(changedPkg);
      this.triggerRebuilds();
    }
  }

  async run() {
    const packemon = this.packemon;
    const chokidar = loadModule.loadModule('chokidar', 'Chokidar is required for file watching.');
    packemon.debug('Starting `watch` process'); // Generate all our build artifacts

    this.packages = await packemon.loadConfiguredPackages(this.getBuildOptions());
    this.packages = packemon.generateArtifacts(this.packages); // Instantiate the watcher for each package source

    const watchPaths = this.packages.map(pkg => pkg.path.append('src/**/*').path());
    packemon.debug('Initializing chokidar watcher for paths:');
    packemon.debug(watchPaths.map(path => ` - ${path}`).join('\n'));
    const watcher = chokidar.watch(watchPaths, {
      ignored: /(^|[/\\])\../u,
      // dotfiles
      ignoreInitial: true,
      persistent: true,
      usePolling: this.poll
    }); // Rebuild when files change

    watcher.on('all', this.enqueueRebuild);
    this.log('Watching for changes...');
  }

  triggerRebuilds() {
    if (this.rebuildTimer) {
      clearTimeout(this.rebuildTimer);
    }

    this.rebuildTimer = setTimeout(() => {
      void this.rebuildPackages();
    }, this.debounce);
  }

  async rebuildPackages() {
    if (this.rebuilding) {
      this.triggerRebuilds();
      return;
    }

    const pkgs = [...this.packagesToRebuild];
    const pkgNames = pkgs.map(pkg => pkg.getName());

    if (pkgs.length === 0) {
      return;
    }

    this.packagesToRebuild.clear();
    this.rebuilding = true;

    try {
      const start = Date.now();
      await Promise.all(pkgs.map(pkg => pkg.build({})));
      this.log(cli.applyStyle('Built %s in %s', 'success'), pkgNames.join(', '), common.formatMs(Date.now() - start));
    } catch (error) {
      if (error instanceof Error) {
        this.log.error(error.message);
      }

      this.log(cli.applyStyle('Failed to build %s', 'failure'), pkgNames.join(', '));
    } finally {
      this.rebuilding = false;
    }
  }

}, (_descriptor = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "debounce", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 150;
  }
}), _descriptor2 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "poll", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "enqueueRebuild", [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, "enqueueRebuild"), _class2.prototype)), _class2)) || _class);
exports.WatchCommand = WatchCommand;
//# sourceMappingURL=Watch.js.map
