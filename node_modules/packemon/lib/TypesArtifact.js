'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const glob = require('fast-glob');

const fs = require('fs-extra');

const common = require('@boost/common');

const debug = require('@boost/debug');

const apiExtractor = require('@microsoft/api-extractor');

const Artifact = require('./Artifact.js');

const removeSourcePath = require('./helpers/removeSourcePath.js');

const apiExtractorConfig = require('./typescript/apiExtractorConfig.js');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const glob__default = /*#__PURE__*/_interopDefault(glob);

const fs__default = /*#__PURE__*/_interopDefault(fs);

class TypesArtifact extends Artifact.Artifact {
  constructor(...args) {
    super(...args);
    this.declarationType = 'standard';
    this.debug = void 0;
  }

  startup() {
    this.debug = debug.createDebugger(['packemon', 'types', this.package.getSlug(), this.getLabel()]);
  }

  async cleanup() {
    // API extractor config files
    await this.removeFiles(this.builds.map(({
      outputName
    }) => this.getApiExtractorConfigPath(outputName)));
  }

  async build(options) {
    this.debug('Building "%s" types artifact with TypeScript', this.declarationType);
    const tsConfig = this.loadTsconfigJson(); // Compile the current projects declarations

    this.debug('Generating declarations at the root using `tsc`');
    await this.package.project.generateDeclarations(options.declarationConfig); // Combine all DTS files into a single file for each input

    if (this.declarationType === 'api') {
      this.debug('Combining declarations into a single API declaration file'); // Resolved compiler options use absolute paths, so we should match

      let dtsBuildPath = this.package.path.append('dts'); // Workspaces use the tsconfig setting, while non-workspaces is hard-coded to "dts"

      if (tsConfig && this.package.project.isWorkspacesEnabled()) {
        var _ref, _tsConfig$options$dec;

        dtsBuildPath = new common.Path((_ref = (_tsConfig$options$dec = tsConfig.options.declarationDir) !== null && _tsConfig$options$dec !== void 0 ? _tsConfig$options$dec : tsConfig.options.outDir) !== null && _ref !== void 0 ? _ref : dtsBuildPath);
      }

      await Promise.all(this.builds.map(({
        inputFile,
        outputName
      }) => this.generateApiDeclaration(outputName, inputFile, dtsBuildPath))); // Remove the TS output directory to reduce package size.
      // We do this in the background to speed up the CLI process!

      this.debug('Removing old and unnecessary declarations in the background');
      void this.removeDeclarationBuild(dtsBuildPath);
    }
  }

  findEntryPoint(outputName) {
    const output = this.builds.find(build => build.outputName === outputName);

    if (!output) {
      return '';
    } // When not generating individual API declarations, we need to mirror the source structure


    const entry = this.declarationType === 'standard' ? removeSourcePath.removeSourcePath(output.inputFile) : outputName;
    return `./${new common.Path('dts', entry)}.d.ts`;
  }

  getLabel() {
    return 'dts';
  }

  getBuildTargets() {
    return ['dts'];
  }

  getPackageExports() {
    const exportMap = {};
    this.builds.forEach(({
      outputName
    }) => {
      exportMap[`./${outputName}`] = {
        types: this.findEntryPoint(outputName)
      };
    });
    return exportMap;
  }

  toString() {
    return `types (${this.getLabel()})`;
  }

  async generateApiDeclaration(outputName, inputFile, dtsBuildPath) {
    const dtsEntryPoint = dtsBuildPath.append(`${removeSourcePath.removeSourcePath(inputFile)}.d.ts`);

    if (!dtsEntryPoint.exists()) {
      console.warn(`Unable to generate declaration for "${outputName}". Declaration entry point "${dtsEntryPoint}" does not exist.`);
      return Promise.resolve();
    } // Create a fake config file


    const configPath = this.getApiExtractorConfigPath(outputName).path();

    const config = _objectSpread(_objectSpread({}, apiExtractorConfig.apiExtractorConfig), {}, {
      projectFolder: this.package.path.path(),
      mainEntryPointFilePath: dtsEntryPoint.path(),
      dtsRollup: _objectSpread(_objectSpread({}, apiExtractorConfig.apiExtractorConfig.dtsRollup), {}, {
        untrimmedFilePath: `<projectFolder>/dts/${outputName}.d.ts`
      })
    }); // Create the config file within the package


    await fs__default.default.writeJson(configPath, config); // Extract all DTS into a single file

    const result = apiExtractor.Extractor.invoke(apiExtractor.ExtractorConfig.loadFileAndPrepare(configPath), {
      localBuild: process.env.NODE_ENV !== "production",
      messageCallback:
      /* istanbul ignore next */
      warn => {
        // eslint-disable-next-line no-param-reassign
        warn.handled = true;

        if (warn.messageId === 'ae-missing-release-tag' || warn.messageId === 'console-preamble' || warn.logLevel === 'verbose') {
          return;
        }

        let level = 'info';

        if (warn.logLevel === 'error') {
          level = 'error';
        } else if (warn.logLevel === 'warning') {
          level = 'warn';
        }

        this.logWithSource(warn.text, level, {
          id: warn.messageId,
          output: `${this.package.getSlug()}:${outputName}`,
          sourceColumn: warn.sourceFileColumn,
          sourceFile: warn.sourceFilePath,
          sourceLine: warn.sourceFileLine
        });
      }
    });

    if (!result.succeeded) {
      console.error(`Generated "${outputName}" types completed with ${result.errorCount} errors and ${result.warningCount} warnings!`);
    }

    return result;
  }

  getApiExtractorConfigPath(outputName) {
    return this.package.path.append(`api-extractor-${outputName}.json`);
  } // This method only exists so that we can mock in tests.
  // istanbul ignore next


  loadTsconfigJson() {
    return this.package.tsconfigJson;
  }
  /**
   * This method is unfortunate but necessary if TypeScript is using project references.
   * When using references, TS uses the `types` (or `typings`) field to determine types
   * across packages. But since we set that field to "dts/index.d.ts" for distributing
   * only the types necessary, it breaks the `tsc --build` unless the `outDir` is "dts".
   *
   * But when this happens, we have all the generated `*.d.ts` and `*.js` files in the "dts"
   * folder, which we do not want to distribute. So we need to manually delete all of them
   * except for the output files we created above.
   *
   * Not sure of a workaround or better solution :(
   */


  async removeDeclarationBuild(dtsBuildPath) {
    const outputs = new Set(this.builds.map(({
      outputName
    }) => `${outputName}.d.ts`)); // Remove all non-output files

    const files = await glob__default.default('*', {
      cwd: dtsBuildPath.path(),
      onlyFiles: true
    }); // Remove all folders

    const folders = await glob__default.default('*', {
      cwd: dtsBuildPath.path(),
      onlyDirectories: true
    });
    await Promise.all([...files, ...folders].filter(file => !outputs.has(file)).map(file => fs__default.default.remove(dtsBuildPath.append(file).path())));
  }

}

exports.TypesArtifact = TypesArtifact;
//# sourceMappingURL=TypesArtifact.js.map
