'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const externals = require('rollup-plugin-node-externals');

const nodePolyfills = require('rollup-plugin-polyfill-node');

const visualizer = require('rollup-plugin-visualizer');

const pluginBabel = require('@rollup/plugin-babel');

const commonjs = require('@rollup/plugin-commonjs');

const json = require('@rollup/plugin-json');

const resolve = require('@rollup/plugin-node-resolve');

const config = require('../babel/config.js');

const constants = require('../constants.js');

const addBinShebang = require('./plugins/addBinShebang.js');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const externals__default = /*#__PURE__*/_interopDefault(externals);

const nodePolyfills__default = /*#__PURE__*/_interopDefault(nodePolyfills);

const visualizer__default = /*#__PURE__*/_interopDefault(visualizer);

const commonjs__default = /*#__PURE__*/_interopDefault(commonjs);

const json__default = /*#__PURE__*/_interopDefault(json);

const resolve__default = /*#__PURE__*/_interopDefault(resolve);

const sharedPlugins = [resolve__default.default({
  extensions: constants.EXTENSIONS,
  preferBuiltins: true
}), commonjs__default.default(), json__default.default({
  compact: true,
  namedExports: false
})];

function getRollupModuleFormat(format) {
  if (format === 'esm' || format === 'mjs' || // UMD needs to be compiled with Babel instead of Rollup,
  // so we use ESM for better interoperability.
  format === 'umd') {
    return 'esm';
  }

  return 'cjs';
}

function getCodeArtifacts(artifact) {
  // Don't include non-code artifacts. We also can't use `instanceof`
  // because of circular dependencies, boo!
  return artifact.package.artifacts.filter(art => 'configGroup' in art && art.configGroup !== artifact.configGroup);
}

function getRollupPaths(artifact, ext) {
  const paths = {};

  if (artifact.bundle) {
    getCodeArtifacts(artifact).forEach(art => {
      Object.entries(art.getInputPaths()).forEach(([outputName, inputPath]) => {
        // All output files are in the same directory, so we can hard-code a relative path
        paths[inputPath] = `./${outputName}.${ext}`;
      });
    });
  }

  return paths;
}

function getRollupExternals(artifact) {
  const foreignInputs = new Set();

  if (artifact.bundle) {
    const sameInputPaths = new Set(Object.values(artifact.getInputPaths()));
    getCodeArtifacts(artifact).forEach(art => {
      Object.values(art.getInputPaths()).forEach(inputPath => {
        if (!sameInputPaths.has(inputPath)) {
          foreignInputs.add(inputPath);
        }
      });
    });
  }

  return (id, parent = '<unknown>') => {
    if (foreignInputs.has(id)) {
      throw new Error(`Unexpected foreign input import. May only import sibling files within the same \`inputs\` configuration group. File "${parent}" attempted to import "${id}".`);
    }

    for (const pattern of artifact.externals) {
      if (id.match(pattern)) {
        return true;
      }
    }

    return false;
  };
}

function getRollupOutputConfig(artifact, features, format) {
  const platform = artifact.platform,
        support = artifact.support;

  const _artifact$getBuildOut = artifact.getBuildOutput(format),
        ext = _artifact$getBuildOut.ext,
        folder = _artifact$getBuildOut.folder;

  const output = {
    dir: artifact.package.path.append(folder).path(),
    format: getRollupModuleFormat(format),
    originalFormat: format,
    interop: 'auto',
    // Map our externals to local paths with trailing extension
    paths: getRollupPaths(artifact, ext),
    // Use our extension for file names
    assetFileNames: '../assets/[name]-[hash][extname]',
    chunkFileNames: `${artifact.bundle ? 'bundle' : '[name]'}-[hash].${ext}`,
    entryFileNames: `[name].${ext}`,
    preserveModules: !artifact.bundle,
    // Use ESM features when not supporting old targets
    generatedCode: support === 'legacy' ? 'es5' : 'es2015',
    preferConst: support !== 'legacy',
    // Output specific plugins
    plugins: [pluginBabel.getBabelOutputPlugin(_objectSpread(_objectSpread({}, config.getBabelOutputConfig(platform, support, format, features)), {}, {
      filename: artifact.package.path.path(),
      // Provide a custom name for the UMD global
      moduleId: format === 'umd' ? artifact.namespace : undefined,
      // Maps are extracted above before transformation
      sourceMaps: false
    })), addBinShebang.addBinShebang()],
    // Always include source maps
    sourcemap: true,
    sourcemapExcludeSources: true
  }; // Disable warnings about default exports

  if (format === 'lib' || format === 'cjs') {
    output.exports = 'auto';
  } // Automatically prepend a shebang for binaries


  if (artifact.bundle) {
    output.banner = ['// Bundled with Packemon: https://packemon.dev\n', `// Platform: ${platform}, Support: ${support}, Format: ${format}\n\n`].join('');
  }

  return output;
}

function getRollupConfig(artifact, features) {
  const packagePath = artifact.package.packageJsonPath.path();
  const isNode = artifact.platform === 'node';
  const isTest = process.env.NODE_ENV === 'test';
  const config$1 = {
    cache: artifact.cache,
    external: getRollupExternals(artifact),
    input: artifact.bundle ? artifact.getInputPaths() : artifact.package.getSourceFiles(),
    output: [],
    // Shared output plugins
    plugins: [// Mark all dependencies in `package.json` as external
    externals__default.default({
      builtins: isNode,
      deps: true,
      devDeps: true,
      optDeps: true,
      packagePath,
      peerDeps: true
    }), // Externals MUST be listed before shared plugins
    ...sharedPlugins, // Declare Babel here so we can parse TypeScript/Flow
    pluginBabel.getBabelInputPlugin(_objectSpread(_objectSpread({}, config.getBabelInputConfig(artifact, features)), {}, {
      babelHelpers: 'bundled',
      exclude: isTest ? [] : constants.EXCLUDE,
      extensions: constants.EXTENSIONS,
      filename: artifact.package.path.path(),
      // Extract maps from the original source
      sourceMaps: true
    }))],
    // Treeshake for smaller builds
    treeshake: artifact.bundle
  }; // Polyfill node modules when platform is not node

  if (!isNode) {
    // @ts-expect-error Types dont match
    config$1.plugins.unshift(nodePolyfills__default.default());
  } // Analyze the bundle for debugging purposes


  if (features.analyze) {
    config$1.plugins.push(visualizer__default.default({
      filename: artifact.getStatsFileName(),
      gzipSize: true,
      open: true,
      sourcemap: true,
      template: features.analyze,
      title: artifact.getStatsTitle()
    }));
  } // Add an output for each format


  config$1.output = artifact.builds.map(build => getRollupOutputConfig(artifact, features, build.format));
  return config$1;
}

exports.getRollupConfig = getRollupConfig;
exports.getRollupExternals = getRollupExternals;
exports.getRollupOutputConfig = getRollupOutputConfig;
//# sourceMappingURL=config.js.map
