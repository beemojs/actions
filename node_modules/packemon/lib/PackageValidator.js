'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const http = require('http');

const https = require('https');

const execa = require('execa');

const glob = require('fast-glob');

const packList = require('npm-packlist');

const semver = require('semver');

const spdxLicenses = require('spdx-license-list');

const common = require('@boost/common');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const http__default = /*#__PURE__*/_interopDefault(http);

const https__default = /*#__PURE__*/_interopDefault(https);

const execa__default = /*#__PURE__*/_interopDefault(execa);

const glob__default = /*#__PURE__*/_interopDefault(glob);

const packList__default = /*#__PURE__*/_interopDefault(packList);

const semver__default = /*#__PURE__*/_interopDefault(semver);

const spdxLicenses__default = /*#__PURE__*/_interopDefault(spdxLicenses);

class PackageValidator {
  constructor(pkg) {
    this.errors = [];
    this.package = void 0;
    this.warnings = [];
    this.package = pkg;
  }

  hasErrors() {
    return this.errors.length > 0;
  }

  hasWarnings() {
    return this.warnings.length > 0;
  }

  async validate(options) {
    const promises = [];

    if (options.meta) {
      this.checkMetadata();
    }

    if (options.deps) {
      this.checkDependencies();
    }

    if (options.engines) {
      promises.push(this.checkEngines());
    }

    if (options.entries) {
      this.checkEntryPoints();
    }

    if (options.files) {
      promises.push(this.checkFiles());
    }

    if (options.license) {
      this.checkLicense();
    }

    if (options.links) {
      promises.push(this.checkLinks());
    }

    if (options.people) {
      promises.push(this.checkPeople());
    }

    if (options.repo) {
      promises.push(this.checkRepository());
    }

    await Promise.all(promises);
    return this;
  }

  checkDependencies() {
    this.package.debug('Checking dependencies');
    const usesLerna = this.package.project.isLernaManaged();
    const workspacePackageNames = new Set(this.package.project.getWorkspacePackageNames());
    const _this$package$package = this.package.packageJson,
          _this$package$package2 = _this$package$package.dependencies,
          dependencies = _this$package$package2 === void 0 ? {} : _this$package$package2,
          _this$package$package3 = _this$package$package.devDependencies,
          devDependencies = _this$package$package3 === void 0 ? {} : _this$package$package3,
          _this$package$package4 = _this$package$package.peerDependencies,
          peerDependencies = _this$package$package4 === void 0 ? {} : _this$package$package4,
          _this$package$package5 = _this$package$package.peerDependenciesMeta,
          peerDependenciesMeta = _this$package$package5 === void 0 ? {} : _this$package$package5,
          _this$package$package6 = _this$package$package.optionalDependencies,
          optionalDependencies = _this$package$package6 === void 0 ? {} : _this$package$package6;
    this.checkDependencyRange(dependencies);
    this.checkDependencyRange(devDependencies);
    this.checkDependencyRange(peerDependencies);
    this.checkDependencyRange(optionalDependencies);
    Object.entries(peerDependencies).forEach(([peerName, versionConstraint]) => {
      const devVersion = semver__default.default.coerce(devDependencies[peerName]);
      const prodVersion = dependencies[peerName];

      if (prodVersion) {
        this.errors.push(`Dependency "${peerName}" defined as both a prod and peer dependency.`);
      } // Avoid further checks if constraint is special.


      if (versionConstraint.includes(':')) {
        return;
      } // When using Lerna, we want to avoid pairing a peer with a dev dependency,
      // as Lerna will update their `package.json` version of all dependent packages!
      // This would accidently publish many packages that shouldn't be.


      if (usesLerna && workspacePackageNames.has(peerName)) {
        if (devVersion) {
          this.errors.push(`Peer dependency "${peerName}" should not define a dev dependency when using Lerna.`);
        }

        return;
      }

      if (!devVersion) {
        var _peerDependenciesMeta;

        if (!((_peerDependenciesMeta = peerDependenciesMeta[peerName]) !== null && _peerDependenciesMeta !== void 0 && _peerDependenciesMeta.optional)) {
          this.warnings.push(`Peer dependency "${peerName}" is missing a version satisfying dev dependency.`);
        }
      } else if (!semver__default.default.satisfies(devVersion.version, versionConstraint)) {
        this.errors.push(`Dev dependency "${peerName}" does not satisfy version constraint of its peer. Found ${devVersion.version}, requires ${versionConstraint}.`);
      }
    });
  }

  checkDependencyRange(deps) {
    Object.entries(deps).forEach(([depName, version]) => {
      if (version.startsWith('file:')) {
        this.errors.push(`Dependency "${depName}" must not require the file system. Found "file:" constraint.`);
      } else if (version.startsWith('link:')) {
        this.errors.push(`Dependency "${depName}" must not require symlinks. Found "link:" constraint.`);
      }
    });
  }

  async checkEngines() {
    this.package.debug('Checking engines');
    const engines = this.package.packageJson.engines;
    const nodeConstraint = engines === null || engines === void 0 ? void 0 : engines.node;
    const npmConstraint = engines === null || engines === void 0 ? void 0 : engines.npm;
    const yarnConstraint = engines === null || engines === void 0 ? void 0 : engines.yarn;

    if (nodeConstraint) {
      const nodeVersion = semver__default.default.coerce(await this.getBinVersion('node'));

      if (nodeVersion && !semver__default.default.satisfies(nodeVersion.version, nodeConstraint)) {
        this.warnings.push(`Node.js does not satisfy engine constraints. Found ${nodeVersion.version}, requires ${nodeConstraint}.`);
      }
    }

    if (npmConstraint) {
      const npmVersion = semver__default.default.coerce(await this.getBinVersion('npm'));

      if (npmVersion && !semver__default.default.satisfies(npmVersion.version, npmConstraint)) {
        this.warnings.push(`npm does not satisfy engine constraints. Found ${npmVersion.version}, requires ${npmConstraint}.`);
      }
    }

    if (yarnConstraint) {
      const yarnVersion = semver__default.default.coerce(await this.getBinVersion('yarn'));

      if (yarnVersion && !semver__default.default.satisfies(yarnVersion.version, yarnConstraint)) {
        this.warnings.push(`Yarn does not satisfy engine constraints. Found ${yarnVersion.version}, requires ${yarnConstraint}.`);
      }
    }
  }

  checkEntryPoints() {
    this.package.debug('Checking entry points');
    const _this$package$package7 = this.package.packageJson,
          bin = _this$package$package7.bin,
          man = _this$package$package7.man,
          exp = _this$package$package7.exports;
    PackageValidator.entryPoints.forEach(field => {
      const relPath = this.package.packageJson[field];

      if (!relPath || typeof relPath !== 'string') {
        if (field === 'main' && !exp) {
          this.errors.push('Missing primary entry point. Provide a `main` or `exports` field.');
        }

        return;
      }

      if (!this.doesPathExist(relPath)) {
        this.errors.push(`Entry point "${field}" resolves to an invalid or missing file.`);
      }
    });

    if (common.isObject(bin)) {
      Object.entries(bin).forEach(([name, path]) => {
        if (!this.doesPathExist(path)) {
          this.errors.push(`Bin "${name}" resolves to an invalid or missing file.`);
        }
      });
    }

    if (Array.isArray(man)) {
      man.forEach(path => {
        if (!this.doesPathExist(path)) {
          this.errors.push(`Manual "${path}" resolves to an invalid or missing file.`);
        }
      });
    }
  }

  async checkFiles() {
    const futureFiles = new Set(await packList__default.default({
      path: this.package.path.path()
    }));
    const presentFiles = new Set(await this.findDistributableFiles()); // First check that our files are in the potential npm list

    const ignored = new Set();
    presentFiles.forEach(file => {
      if (!futureFiles.has(file)) {
        ignored.add(file);
      }
    });

    if (ignored.size > 0) {
      this.errors.push(`The following files are being ignored from publishing: ${[...ignored].join(', ')}`);
    } // Then check that npm isnt adding something unwanted


    const unwanted = new Set();
    futureFiles.forEach(file => {
      if (!presentFiles.has(file)) {
        unwanted.add(file);
      }
    });

    if (unwanted.size > 0) {
      this.warnings.push(`The following files are being inadvertently published: ${[...unwanted].join(', ')}`);
    }
  }

  checkLicense() {
    this.package.debug('Checking license');
    const license = this.package.packageJson.license;
    const spdxLicenseTypes = new Set(Object.keys(spdxLicenses__default.default).map(key => key.toLocaleLowerCase()));

    if (license) {
      common.toArray(typeof license === 'string' ? {
        type: license,
        url: spdxLicenses__default.default[license]
      } : license).forEach(l => {
        if (!spdxLicenseTypes.has(l.type.toLocaleLowerCase())) {
          this.errors.push(`Invalid license "${l.type}". Must be an official SPDX license type.`);
        }
      });
    } else {
      this.errors.push('Missing license.');
    }

    if (!this.doesPathExist('LICENSE') && !this.doesPathExist('LICENSE.md')) {
      this.errors.push('No license file found in package. Must contain one of LICENSE or LICENSE.md.');
    }
  }

  async checkLinks() {
    this.package.debug('Checking links');
    const _this$package$package8 = this.package.packageJson,
          bugs = _this$package$package8.bugs,
          homepage = _this$package$package8.homepage;
    const bugsUrl = common.isObject(bugs) ? bugs.url : bugs;

    if (homepage && !(await this.doesUrlExist(homepage))) {
      this.warnings.push('Homepage link is invalid. URL is either malformed or upstream is down.');
    }

    if (bugsUrl && !(await this.doesUrlExist(bugsUrl))) {
      this.warnings.push('Bugs link is invalid. URL is either malformed or upstream is down.');
    }
  }

  checkMetadata() {
    this.package.debug('Checking metadata');
    const _this$package$package9 = this.package.packageJson,
          name = _this$package$package9.name,
          version = _this$package$package9.version,
          description = _this$package$package9.description,
          keywords = _this$package$package9.keywords,
          isPrivate = _this$package$package9.private;

    if (!name) {
      this.errors.push('Missing name.');
    } else if (!common.isModuleName(name)) {
      this.errors.push('Invalid name format. Must contain alphanumeric characters and dashes.');
    } // Only validate name when a private package


    if (isPrivate) {
      return;
    }

    if (!version) {
      this.errors.push('Missing version.');
    }

    if (!description) {
      this.warnings.push('Missing description.');
    }

    if (!keywords || keywords.length === 0) {
      this.warnings.push('Missing keywords.');
    }

    if (!this.doesPathExist('README') && !this.doesPathExist('README.md')) {
      this.errors.push('No read me found in package. Must contain one of README or README.md.');
    }
  }

  async checkPeople() {
    this.package.debug('Checking author and contributors');
    const _this$package$package10 = this.package.packageJson,
          author = _this$package$package10.author,
          contributors = _this$package$package10.contributors;

    if (!author) {
      this.warnings.push('Missing author.');
    } else if (common.isObject(author)) {
      if (!author.name) {
        this.errors.push('Missing author name.');
      }

      if (author.url && !(await this.doesUrlExist(author.url))) {
        this.warnings.push('Author URL is invalid. URL is either malformed or upstream is down.');
      }
    }

    if (Array.isArray(contributors)) {
      await Promise.all(contributors.map(async contrib => {
        if (typeof contrib === 'string') {
          return;
        }

        if (!contrib.name) {
          this.errors.push('Missing contributor name.');
        }

        if (contrib.url && !(await this.doesUrlExist(contrib.url))) {
          this.warnings.push('Contributor URL is invalid. URL is either malformed or upstream is down.');
        }
      }));
    } else if (contributors) {
      this.warnings.push('Contributors must be an array.');
    }
  }

  async checkRepository() {
    this.package.debug('Checking repository');
    const repo = this.package.packageJson.repository;
    const url = common.isObject(repo) ? repo.url : repo;

    if (!url) {
      this.errors.push('Missing repository.');
    } else if (url.startsWith('http') && !(await this.doesUrlExist(url))) {
      this.warnings.push('Repository is invalid. URL is either malformed or upstream is down.');
    }

    if (common.isObject(repo)) {
      const dir = repo.directory;

      if (dir && !this.package.project.root.append(dir).exists()) {
        this.errors.push(`Repository directory "${dir}" does not exist.`);
      }
    }
  }

  doesPathExist(path) {
    return this.package.path.append(path).exists();
  } // istanbul ignore next


  async doesUrlExist(url) {
    return new Promise(resolve => {
      const request = url.startsWith('https') ? https__default.default.request : http__default.default.request;
      const ping = request(url, () => {
        resolve(true);
        ping.abort();
      });
      ping.on('error', () => {
        resolve(false);
        ping.abort();
      });
      ping.write('');
      ping.end();
    });
  }

  async findDistributableFiles() {
    var _this$package$package11;

    // https://github.com/npm/npm-packlist/blob/main/index.js#L29
    const patterns = ['(readme|copying|license|licence)*', 'package.json'];
    (_this$package$package11 = this.package.packageJson.files) === null || _this$package$package11 === void 0 ? void 0 : _this$package$package11.forEach(file => {
      if (file.endsWith('/')) {
        patterns.push(`${file}**/*`);
      } else {
        patterns.push(file);
      }
    });
    return glob__default.default(patterns, {
      caseSensitiveMatch: false,
      cwd: this.package.path.path(),
      ignore: ['node_modules']
    });
  }

  async getBinVersion(bin) {
    try {
      return (await execa__default.default(bin, ['-v'], {
        preferLocal: true
      })).stdout.trim();
    } catch {
      // istanbul ignore next
      return '';
    }
  }

}

PackageValidator.entryPoints = ['main', 'module', 'browser', 'types', 'typings', 'bin', 'man'];
exports.PackageValidator = PackageValidator;
//# sourceMappingURL=PackageValidator.js.map
