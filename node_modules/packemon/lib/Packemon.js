'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');

const fs = require('fs-extra');

const rimraf = require('rimraf');

const common = require('@boost/common');

const debug = require('@boost/debug');

const event = require('@boost/event');

const pipeline = require('@boost/pipeline');

const CodeArtifact = require('./CodeArtifact.js');

const matchesPattern = require('./helpers/matchesPattern.js');

const Package = require('./Package.js');

const PackageValidator = require('./PackageValidator.js');

const Project = require('./Project.js');

const schemas = require('./schemas.js');

const TypesArtifact = require('./TypesArtifact.js');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const fs__default = /*#__PURE__*/_interopDefault(fs);

const rimraf__default = /*#__PURE__*/_interopDefault(rimraf);

var _dec, _class;

let Packemon = (_dec = common.Memoize(), (_class = class Packemon {
  constructor(cwd = process.cwd()) {
    this.debug = void 0;
    this.onPackageBuilt = new event.Event('package-built');
    this.onPackagesLoaded = new event.Event('packages-loaded');
    this.project = void 0;
    this.root = void 0;
    this.root = common.Path.resolve(cwd);
    this.project = new Project.Project(this.root);
    this.debug = debug.createDebugger('packemon:core');
    this.debug('Initializing packemon in project %s', this.root);
    this.project.checkEngineVersionConstraint();
  }

  async build(baseOptions) {
    this.debug('Starting `build` process');
    const options = common.optimal(baseOptions, schemas.buildBlueprint);
    let packages = await this.loadConfiguredPackages(options);
    packages = this.generateArtifacts(packages, options);

    if (packages.length === 0) {
      throw new Error('No packages to build.');
    } // Build packages in parallel using a pool


    const pipeline$1 = new pipeline.PooledPipeline(new pipeline.Context());
    pipeline$1.configure({
      concurrency: options.concurrency,
      timeout: options.timeout
    });
    packages.forEach(pkg => {
      pipeline$1.add(pkg.getName(), async () => {
        await pkg.build(options);
        this.onPackageBuilt.emit([pkg]);
      });
    });

    const _await$pipeline$1$run = await pipeline$1.run(),
          errors = _await$pipeline$1$run.errors; // Always cleanup whether a successful or failed build


    await this.cleanTemporaryFiles(packages); // Throw to trigger an error screen in the terminal

    if (errors.length > 0) {
      throw errors[0];
    }
  }

  async clean() {
    this.debug('Starting `clean` process');
    const packages = await this.loadConfiguredPackages(); // Clean package specific files

    await this.cleanTemporaryFiles(packages); // Clean build formats

    const formatFolders = '{cjs,dts,esm,lib,mjs,umd}';
    const pathsToRemove = [];

    if (this.project.isWorkspacesEnabled()) {
      this.project.workspaces.forEach(ws => {
        pathsToRemove.push(new common.Path(ws, formatFolders).path());
      });
    } else {
      pathsToRemove.push(`./${formatFolders}`);
    }

    await Promise.all(pathsToRemove.map(rfPath => new Promise((resolve, reject) => {
      this.debug(' - %s', rfPath);
      rimraf__default.default(rfPath, error => {
        if (error) {
          reject(error);
        } else {
          resolve(undefined);
        }
      });
    })));
  }

  async validate(baseOptions) {
    this.debug('Starting `validate` process');
    const options = common.optimal(baseOptions, schemas.validateBlueprint);
    const packages = await this.loadConfiguredPackages(options);
    return Promise.all(packages.map(pkg => new PackageValidator.PackageValidator(pkg).validate(options)));
  }
  /**
   * Find all packages within a project. If using workspaces, return a list of packages
   * from each workspace glob. If not using workspaces, assume project is a package.
   */


  async findPackagesInProject({
    filter,
    skipPrivate
  } = {}) {
    this.debug('Finding packages in project');
    const pkgPaths = [];
    this.project.workspaces = this.project.getWorkspaceGlobs({
      relative: true
    }); // Multi package repo

    if (this.project.workspaces.length > 0) {
      this.debug('Workspaces enabled, finding packages using globs');
      this.project.getWorkspacePackagePaths().forEach(filePath => {
        pkgPaths.push(common.Path.create(filePath).append('package.json'));
      }); // Single package repo
    } else {
      this.debug('Not workspaces enabled, using root as package');
      pkgPaths.push(this.root.append('package.json'));
    }

    this.debug('Found %d package(s)', pkgPaths.length);
    let packages = await Promise.all(pkgPaths.map(async pkgPath => {
      const contents = common.json.parse(await fs__default.default.readFile(pkgPath.path(), 'utf8'));
      this.debug(' - %s: %s', contents.name, pkgPath.path().replace(this.root.path(), '').replace('package.json', ''));
      return {
        metadata: this.project.createWorkspaceMetadata(pkgPath),
        package: contents
      };
    })); // Skip `private` packages

    if (skipPrivate) {
      const privatePackageNames = [];
      packages = packages.filter(pkg => {
        if (pkg.package.private) {
          privatePackageNames.push(pkg.package.name);
          return false;
        }

        return true;
      });
      this.debug('Filtering private packages: %s', privatePackageNames.join(', '));
    } // Filter packages based on a pattern


    if (filter) {
      const filteredPackageNames = [];
      packages = packages.filter(pkg => {
        const name = pkg.package.name;

        if (!matchesPattern.matchesPattern(name, filter)) {
          filteredPackageNames.push(name);
          return false;
        }

        return true;
      });
      this.debug('Filtering packages with pattern %s: %s', filter, filteredPackageNames.join(', '));
    } // Error if no packages are found


    if (packages.length === 0) {
      throw new Error('No packages found in project.');
    }

    return packages;
  }
  /**
   * Generate build and optional types artifacts for each package in the list.
   */


  generateArtifacts(packages, {
    declaration = 'none',
    filterFormats,
    filterPlatforms
  } = {}) {
    this.debug('Generating artifacts for packages');
    packages.forEach(pkg => {
      const typesBuilds = {};
      const sharedLib = this.requiresSharedLib(pkg);
      pkg.configs.forEach((config, index) => {
        let builds = config.formats.map(format => ({
          format
        }));

        if (filterFormats) {
          this.debug('Filtering formats with pattern: %s', filterFormats);
          builds = builds.filter(build => matchesPattern.matchesPattern(build.format, filterFormats));
        }

        if (filterPlatforms) {
          this.debug('Filtering platforms with pattern: %s', filterPlatforms);

          if (!matchesPattern.matchesPattern(config.platform, filterPlatforms)) {
            return;
          }
        }

        if (builds.length === 0) {
          return;
        }

        const artifact = new CodeArtifact.CodeArtifact(pkg, builds);
        artifact.bundle = config.bundle;
        artifact.configGroup = index;
        artifact.externals = config.externals;
        artifact.inputs = config.inputs;
        artifact.namespace = config.namespace;
        artifact.platform = config.platform;
        artifact.sharedLib = sharedLib;
        artifact.support = config.support;
        pkg.addArtifact(artifact);
        Object.entries(config.inputs).forEach(([outputName, inputFile]) => {
          typesBuilds[outputName] = {
            inputFile,
            outputName
          };
        });
      });

      if (declaration !== 'none') {
        const artifact = new TypesArtifact.TypesArtifact(pkg, Object.values(typesBuilds));
        artifact.declarationType = declaration;
        pkg.addArtifact(artifact);
      }

      this.debug(' - %s: %s', pkg.getName(), pkg.artifacts.join(', '));
    }); // Remove packages that have no artifacts

    return packages.filter(pkg => pkg.artifacts.length > 0);
  }
  /**
   * Find and load all packages that have been configured with a `packemon`
   * block in their `package.json`. Once loaded, validate the configuration.
   */


  async loadConfiguredPackages(options) {
    const packages = this.validateAndPreparePackages(await this.findPackagesInProject(options));
    this.onPackagesLoaded.emit([packages]);
    return packages;
  }
  /**
   * Cleanup all package and artifact related files in all packages.
   */


  async cleanTemporaryFiles(packages) {
    this.debug('Cleaning temporary build files');
    await Promise.all(packages.map(pkg => pkg.cleanup()));
  }
  /**
   * Format "lib" is a shared format across all platforms,
   * and when a package wants to support multiple platforms,
   * we must account for this and alter the output paths.
   */


  requiresSharedLib(pkg) {
    const platformsToCheck = new Set();
    let libFormatCount = 0;
    pkg.configs.forEach(config => {
      platformsToCheck.add(config.platform);
      config.formats.forEach(format => {
        if (format === 'lib') {
          libFormatCount += 1;
        }
      });
    });
    return platformsToCheck.size > 1 && libFormatCount > 1;
  }
  /**
   * Validate that every loaded package has a valid `packemon` configuration,
   * otherwise skip it. All valid packages will return a `Package` instance.
   */


  validateAndPreparePackages(packages) {
    this.debug('Validating found packages');
    const nextPackages = [];
    packages.forEach(({
      metadata,
      package: contents
    }) => {
      if (!contents.packemon) {
        this.debug('No `packemon` configuration found for %s, skipping', contents.name);
        return;
      }

      if (!common.isObject(contents.packemon) && !Array.isArray(contents.packemon)) {
        this.debug('Invalid `packemon` configuration for %s, must be an object or array of objects', contents.name);
        return;
      }

      const pkg = new Package.Package(this.project, common.Path.create(metadata.packagePath), contents);
      pkg.setConfigs(common.toArray(contents.packemon));
      nextPackages.push(pkg);
    });
    return nextPackages;
  }

}, _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "loadConfiguredPackages", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "loadConfiguredPackages"), _class.prototype), _class));
exports.Packemon = Packemon;
//# sourceMappingURL=Packemon.js.map
