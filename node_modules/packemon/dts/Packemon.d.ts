import { Path, WorkspacePackage } from '@boost/common';
import { Debugger } from '@boost/debug';
import { Event } from '@boost/event';
import { Package } from './Package';
import { PackageValidator } from './PackageValidator';
import { Project } from './Project';
import { BuildOptions, FilterOptions, PackemonPackage, ValidateOptions } from './types';
export declare class Packemon {
    readonly debug: Debugger;
    readonly onPackageBuilt: Event<[Package], string>;
    readonly onPackagesLoaded: Event<[Package[]], string>;
    readonly project: Project;
    readonly root: Path;
    constructor(cwd?: string);
    build(baseOptions: BuildOptions): Promise<void>;
    clean(): Promise<void>;
    validate(baseOptions: Partial<ValidateOptions>): Promise<PackageValidator[]>;
    /**
     * Find all packages within a project. If using workspaces, return a list of packages
     * from each workspace glob. If not using workspaces, assume project is a package.
     */
    findPackagesInProject({ filter, skipPrivate }?: FilterOptions): Promise<WorkspacePackage<PackemonPackage>[]>;
    /**
     * Generate build and optional types artifacts for each package in the list.
     */
    generateArtifacts(packages: Package[], { declaration, filterFormats, filterPlatforms }?: BuildOptions): Package[];
    /**
     * Find and load all packages that have been configured with a `packemon`
     * block in their `package.json`. Once loaded, validate the configuration.
     */
    loadConfiguredPackages(options?: FilterOptions): Promise<Package[]>;
    /**
     * Cleanup all package and artifact related files in all packages.
     */
    protected cleanTemporaryFiles(packages: Package[]): Promise<void>;
    /**
     * Format "lib" is a shared format across all platforms,
     * and when a package wants to support multiple platforms,
     * we must account for this and alter the output paths.
     */
    protected requiresSharedLib(pkg: Package): boolean;
    /**
     * Validate that every loaded package has a valid `packemon` configuration,
     * otherwise skip it. All valid packages will return a `Package` instance.
     */
    protected validateAndPreparePackages(packages: WorkspacePackage<PackemonPackage>[]): Package[];
}
//# sourceMappingURL=Packemon.d.ts.map